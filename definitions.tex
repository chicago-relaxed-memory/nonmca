% \section{Notes}
% GPU stuff:
% \begin{itemize}
% \item Vulcan/Alloy
% \item OpenCL
% \item AMD PTX
% \item Matthew Sinclair/Sarita Adve stuff ``Chasing Away RAts- Semantics and
%   Evaluation for Relaxed Atomics on Heterogeneous Systems'' and his thesis
% \end{itemize}

\section{Model}
\label{sec:model}

\subsection{Preliminaries}
\label{sec:prelim}
The syntax is built from
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$, $\bVal$, $\cVal$, $\dVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$, $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$,  $\cExp$,
\item a set of \emph{thread ids} $\Thrd$, ranged over by
  $\aThrd$, $\bThrd$.
\end{itemize}

\emph{Memory references} are tagged values, written $\REF{\cVal}$.  Let $\Loc$
be the set of memory references, ranged over by $\aLoc$, $\bLoc$, $\cLoc$.
We require that:
\begin{itemize}
\item values and registers are disjoint, 
\item values include at least the constants $0$ and $1$,  
\item expressions include at least registers and values, 
\item references do not appear in expressions: $\aExp[\bExp/\aLoc]=\aExp$,
\item thread ids include the \emph{top-level} id $\topThrd$. % and the \emph{test} id $\testThrd$. 
\end{itemize}
We model the following language.
\begin{gather*}
  \begin{aligned}
    \amode,\bmode \BNFDEF& \mWK
    \BNFSEP \mRLX
    \BNFSEP \mREL
    \BNFSEP \mACQ
    \BNFSEP \mRA 
    \BNFSEP \mSC
    % &
    % \fmode \BNFDEF& \fACQ 
    % \BNFSEP \fREL
    % \BNFSEP \fSC
    &\qquad \qquad
    \ascope,\bscope \BNFDEF& \sCTA
    \BNFSEP \sGPU
    \BNFSEP \sSYS
  \end{aligned}
  \\
  \begin{aligned}
    \aCmd%,\aTest
    \BNFDEF& \SKIP
    \BNFSEP \LET{\aReg}{\aExp}
    \BNFSEP \PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}
    \BNFSEP \PW[\amode]{\REF{\cExp}}[\ascope]{\aExp}
    \BNFSEP \PF[\ascope]{\fmode}
    \BNFSEP \IF{\aExp} \THEN \aCmd_1 \ELSE \aCmd_2 \FI
    \BNFSEP \aCmd_1 \SEMI \aCmd_2
    \\[-.5ex]
    \BNFSEP& \aCmd_1 \LPAR[\bThrd] \aCmd_2
    \BNFSEP \PCAS[\amode][\bmode]{\REF{\cExp}\,}[\ascope]{\aReg}{\aExp}{\bExp}
    \BNFSEP \PFADD[\amode][\bmode]{\REF{\cExp}\,}[\ascope]{\aReg}{\aExp}
    \BNFSEP \PEXCHG[\amode][\bmode]{\REF{\cExp}\,}[\ascope]{\aReg}{\aExp}
    % \BNFSEP \PCAS[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}{\bExp}
    % \BNFSEP \PFADD[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
    % \BNFSEP \PEXCHG[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
  \end{aligned}
\end{gather*}
% \emph{Access modes}, $\amode$, are {weak} ($\mWK$), are {relaxed} ($\mRLX$),
% {release-acquire} ($\mRA$), and {sequentially consistent} ($\mSC$).
% $\mRA$/$\mSC$ accesses are collectively known as \emph{synchronized
% accesses}.
% % 
% \emph{Fence modes}, $\bmode$, are {acquire} ($\fACQ$), {release} ($\fREL$), 
% and {acquire-release} ($\fSC$).  

\emph{Access modes}, $\amode$, are {weak} ($\mWK$), {relaxed} ($\mRLX$),
{release} ($\mREL$), {acquire} ($\mACQ$), {release-acquire} ($\mRA$), and
{sequentially consistent} ($\mSC$).
% 
Let expressions ($\LET{\aReg}{\aExp}$) only affect thread-local state and
thus do not have a mode.
% 
Reads ($\PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}$) support
$\mWK$,
$\mRLX$,
% $\mREL$,
$\mACQ$,
% $\mRA$, 
$\mSC$. 
Writes ($\PW[\amode]{\REF{\cExp}}[\ascope]{\aReg}$) support
$\mWK$,
$\mRLX$,
$\mREL$,
% $\mACQ$,
% $\mRA$, 
$\mSC$. 
Fences ($\PF[\ascope]{\fmode}$) support
% $\mWK$,
% $\mRLX$,
$\mREL$,
$\mACQ$,
$\mRA$, 
$\mSC$.
% 
In the atomic update operations, $\amode$ is a read and $\bmode$ is a write;
we require that $\aReg$ does not occur in $\cExp$.

\emph{Scopes}, $\ascope$, are thread group ($\sCTA$), processor ($\sGPU$) and
system ($\sSYS$).

\emph{Commands}, aka \emph{statements}, $\aCmd$, include memory accesses at a
given mode, as well as the usual structural constructs.  Following
\cite{DBLP:conf/icfp/FerreiraHJ96}, $\LPAR$ denotes parallel composition.  If
$(\aCmd_1 \LPAR[\bThrd] \aCmd_2)$ is executed with thread \ID{} $\aThrd$, then
$\aCmd_2$ runs with \ID{} $\bThrd$ and $\aCmd_1$ continues under \ID{} $\aThrd$.
Top level programs run with thread \ID{} $\topThrd$.  In examples, we usually
drop thread \ID{}s.  We use the symmetric $\PAR$ operator when there is no
continuation after the parallel composition.


The semantics is built from the following.
\begin{itemize}
\item a set of \emph{events} $\AllEvents$, ranged over by $\aEv$, $\bEv$,
  $\cEv$, $\dEv$, 
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$, 
\item a set of \emph{logical formulae} $\Formulae$, ranged over by $\aForm$,
  $\bForm$, $\cForm$.
\end{itemize}
Subsets of $\AllEvents$ are ranged over by $\aEvs$, $\bEvs$, $\cEvs$,
$\dEvs$.


\begin{itemize}
\item registers include %\emph{event registers}
  $\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$ which do not appear in commands:
  $\aCmd[\bExp/\uReg{\aEv}]=\aCmd$,
\item formulae include equalities $(\aExp{=}\bExp)$ and $(\aLoc{=}\aExp)$,
\item formulae are closed under negation, conjunction, disjunction, and
  substitutions $[\aExp/\aReg]$, $[\aExp/\aLoc]$,
\item there is a relation $\rimpliesdef$ between
  formulae, capturing entailment, 
\item $\rimpliesdef$ has the expected semantics for $=$, $\lnot$, $\land$, $\lor$,
  $\limplies$ and substitution.
\end{itemize}
We relax the first assumption in examples, assuming that each register is
assigned at most once.

Logical formulae include equations over registers, such as
$(\aReg{=}\bReg{+}1)$.  For \xLIR{}, we also include equations over memory
references, such as $(\aLoc{=}1)$.  Formulae are subject to substitutions;
actions are not.  We use expressions as formulae, coercing $\aExp$ to
$\aExp{\neq}0$.  Equations have precedence over logical operators; thus
$\aReg{=}\aVal\limplies\bReg{>}\bVal$ is read
$(\aReg{=}\aVal)\limplies(\bReg{>}\bVal)$.  As usual, implication associates
to the right; thus $\aForm\limplies\bForm\limplies\cForm$ is read
$\aForm\limplies(\bForm\limplies\cForm)$.

We say
$\aForm$ is a \emph{tautology} if $\TRUE\vDash\aForm$.
We say
$\aForm$ is \emph{unsatisfiable} if $\aForm\vDash\FALSE$.



We require several binary relations between actions, detailed in the next
subsection: 
$\roverlapsdef$, 
$\rsoverlapsdef$,
$\rmatchesdef$, 
$\rsmatchesdef$, 
$\rsfencesdef$, 
$\rblocksdef$, 
$\rsyncdelaysdef$
and $\rcodelaysdef$.
We also require that there is a subsets of actions, distinguishing
$\sreaddef$ and $\sreleasedef$ actions, and an operator
$\fmerge{}{}:\Act\times\Act\fun2^{\Act}$.


\subsection{Actions}
\label{sec:actions}

We combine access and fence modes into a single order:
% \begin{align*}
%   \begin{tikzcenter}
%     \node (wk)  at (-1, 0) {$\mathstrut\mWK$};
%     \node (rlx) at (0, 0) {$\mathstrut\mRLX$};
%     \node (ra)  at (1, 0) {$\mathstrut\mRA$};
%     \node (sc)  at (2, 0) {$\mathstrut\mSC$};
%     \draw[->](wk)to(rlx);
%     \draw[->](rlx)to(ra);
%     \draw[->](ra)to(sc);
%   \end{tikzcenter}
%   &&
%   \begin{tikzcenter}
%     \node (fsc) at (3, 0) {$\mathstrut\fSC$};
%     \node (rel) at (2, -0.2) {$\mathstrut\fREL$};
%     \node (acq) at (2,  0.2) {$\mathstrut\fACQ$};
%     \draw[->](rel)to(fsc);
%     \draw[->](acq)to(fsc);
%   \end{tikzcenter}
% \end{align*}
\begin{math}
  \!\!\smash{\hbox{\begin{tikzcenter}
        \node (wk)  at (-1, 0) {$\mathstrut\mWK$};
        \node (rlx) at (0, 0) {$\mathstrut\mRLX$};
        \node (rel) at (1,  0.2) {$\mathstrut\mREL$};
        \node (acq) at (1, -0.2) {$\mathstrut\mACQ$};
        \node (ra)  at (2, 0) {$\mathstrut\mRA$};
        \node (sc)  at (3, 0) {$\mathstrut\mSC$};
        \draw[->](wk)to(rlx);
        \draw[->](rlx)to(rel);
        \draw[->](rlx)to(acq);
        \draw[->](rel)to(ra);
        \draw[->](acq)to(ra);
        \draw[->](ra)to(sc);
      \end{tikzcenter}}}\!\!.
\end{math}
We write $\amode\lemode\bmode$ for this order.
Let $\amode\lubmode\bmode$ denote the least upper bound of $\amode$ and $\bmode$.

Let actions be reads, writes and fences:
\begin{displaymath}
  \aAct,\bAct \BNFDEF \DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DF[\ascope]{\fmode}[\aThrd]
\end{displaymath}
In examples, we systematically drop the default mode $\mRLX$ and the default
scope $\sSYS$.  In definitions, we drop elements of actions that are
existentially quantified.
% 
We write $\DXP[\amode]{\aLoc}[\ascope]{}[\aThrd]$ to stand for an
\emph{access}: either $\DWP[\amode]{\aLoc}[\ascope]{}[\aThrd]$ or
$\DRP[\amode]{\aLoc}[\ascope]{}[\aThrd]$.
% , or $\DFP[\ascope]{\amode}[\aThrd]$.
We write $\DWP[\gemode\mREL]{}{}$ to stand for either $\DWP[\mREL]{}{}$ or
$\DWP[\mSC]{}{}$, and similarly for other actions and modes.

We say $\aAct \rmatchesdef \bAct$ if $\aAct=\DWP{\aLoc}{\aVal}$ and $\bAct=\DRP{\aLoc}{\aVal}$.

We say $\aAct \rblocksdef \bAct$ if $\aAct=\DWP{\aLoc}{}$ and $\bAct=\DRP{\aLoc}{}$, regardless of value.

We say $\aAct \roverlapsdef \bAct$ if $\aAct=\DXP{\aLoc}{}$ and
$\bAct=\DXP{\aLoc}{}$, regardless of access type or value.
% they access the same location.

We say $\aAct \rcodelaysdef \bAct$ if
\begin{math}
  (\aAct,\bAct)\in
  \{(\DW{\aLoc}{}, \DW{\aLoc}{}),\;(\DR{\aLoc}{}, \DW{\aLoc}{}),\;(\DW{\aLoc}{}, \DR{\aLoc}{})\} \cup 
  % \{(\DW[\mSC]{}{}\Cb \DW[\mSC]{}{})\Cc(\DR[\mSC]{}{}\Cb \DW[\mSC]{}{}) \Cc(\DW[\mSC]{}{}\Cb \DR[\mSC]{}{})\Cc(\DR[\mSC]{}{}\Cb \DR[\mSC]{}{})\}
  \{(\DX[\mSC]{}{},\DX[\mSC]{}{})\}
\end{math}.

We say $\aAct \rsyncdelaysdef \bAct$ if
\begin{math}
  (\aAct,\bAct)\in
  \{(\aAct,             \DW[\gemode\mREL]{}{}     )\Cc
  (\aAct,               \DF{\gemode\fREL}        )\Cc
  (\DR{}{},             \DF{\gemode\fACQ}        )\Cc
  (\DR[\gemode\mACQ]{}{},\bAct                    )\Cc
  (\DF{\gemode\fACQ},   \bAct                    )\Cc
  (\DF{\gemode\fREL},   \DW{}{}                  )\Cc
  (\DW[\gemode\mREL]{\aLoc}{},\DW{\aLoc}{})\}
\end{math}.\footnote{For \PTX, one could additionally include
  \begin{math}
    (\DR{\aLoc}{}, \DR[\gemode\mACQ]{\aLoc}{}),
  \end{math}
  but this is not sound for Arm or \IMM{}.}

Let $\DWP[\gemode\mREL]{}{}$ and $\DFP{\gemode\fREL}$ be
$\sreleasedef$ actions.  Actions $\DRP{}{}$ are $\sreaddef$ actions.

\begin{definition}
  We assume two equivalences:
  $\PBR{\xgpu}\subseteq(\Thrd\times\Thrd)$ partitions threads by
  \emph{processor}, and $\PBR{\xcta}\subseteq\PBR{\xgpu}$ refines the processor
  partitioning into \emph{thread groups}.
  
  We say
  $\DXP[\amode_1]{\aLoc}[\ascope_1]{}[\aThrd_1] \rsoverlapsdef
  \DXP[\xmode_2]{\aLoc}[\xscope_2]{}[\xThrd_2]$ when %they overlap and
  either
  \begin{multicols}{2}
    \begin{enumerate}[,label=(2\alph*),ref=2\alph*]      
    \item[{\labeltext[1]{(1)}{moral-local}}]
    $\aThrd_1=\xThrd_2$, or
    \labeltext[2]{}{moral-nonlocal}
    \item $\amode_1,\xmode_2\neq\mWK$,
    \item if $\ascope_1=\sCTA$ or $\xscope_2=\sCTA$ then $\aThrd_1\xcta\xThrd_2$, and
    \item if $\ascope_1=\sGPU$ or $\xscope_2=\sGPU$ then $\aThrd_1\xgpu\xThrd_2$.
    \end{enumerate}
  \end{multicols}
  \smallskip

  We say
  $\DFP[\ascope_1]{\amode_1}[\aThrd_1] \rsfencesdef \DFP[\xscope_2]{\xmode_2}[\xThrd_2]$
  when $\amode_1=\xmode_2=\fSC$ and either \eqref{moral-local} or
  \eqref{moral-nonlocal} apply, from the definition of $\rsoverlaps$.

  We say $\aAct \rsmatchesdef \bAct$ when $\aAct$ is a release, $\bAct$ is an
  acquire, and either $\aAct\rsoverlaps \bAct$ or $\aAct\rsfences \bAct$.

\end{definition}

Note that for a \CPU{}s, all action have scope $\sSYS$ and mode $\mRLX$ or
greater.  For this subset of actions, $\rsoverlapsdef$ is the same as
$\roverlapsdef$ and $\rsfencesdef$ applies to any pair of $\fSC$ fences.






\subsection{Pomsets with Predicate Transformers}
\label{sec:pomsets}

\begin{definition}
  \label{def:trans}
  A \emph{predicate transformer} is a %monotone
  function
  $\aTr{}{}:\Formulae\fun\Formulae$ such that
  \begin{multicols}{2}
    \begin{enumerate}[,label=(\textsc{x}\arabic*),ref=\textsc{x}\arabic*]
    \item \label{tr-false}
      $\aTr{}{\FALSE}$ is $\FALSE$,    
    \item \label{tr-and}
      $\aTr{}{\bForm_1\land\bForm_2}$ is $\aTr{}{\bForm_1}\land\aTr{}{\bForm_2}$,    
    \item \label{tr-or}
      $\aTr{}{\bForm_1\lor\bForm_2}$ is $\aTr{}{\bForm_1}\lor\aTr{}{\bForm_2}$, 
    \item \label{tr-implies}
      if $\aForm \rimplies \bForm$, then $\aTr{}{\aForm} \rimplies
      \aTr{}{\bForm}$.
    \end{enumerate}
  \end{multicols}
\end{definition}

\begin{definition}
  \label{def:family}
  A \emph{family of predicate transformers} for $\aEvs$ consists of a
  predicate transformer $\aTr{\bEvs}{}$ for each $\bEvs\subseteq\AllEvents$,
  such that if $\cEvs \cap \aEvs \subseteq \bEvs$ then
  $\aTr{\cEvs}{\bForm} \rimplies \aTr{\bEvs}{\bForm}$.

  We write $\aTr{}{}$ as an abbreviation of $\aTr{\aEvs}{}$.
\end{definition}

\begin{definition}
  \label{def:pomset}
  A \emph{pomset with predicate transformers} 
  is a tuple $(\Event, \labeling, \labelingForm, \aTr{}{}, {\aTerm}, {\ledep}, {\lesync}, {\leloc}, {\rrmw})$ where
  \begin{enumerate}[,label=(\textsc{m}\arabic*),ref=\textsc{m}\arabic*]
    \makecounter{BE}
  \item \label{pom-E} \makecounter{E}
    $\Event\subset\AllEvents$ is a set of \emph{events},
    \makecounter{Blambda}
  \item \label{pom-lambda} \makecounter{lambda}
    $\labeling: \Event \fun \Act$ defines a \emph{label} for each event,
    \makecounter{Bkappa}
  \item \label{pom-kappa} \makecounter{kappa}
    $\labelingForm:\aEvs\fun\Formulae$ defines a \emph{precondition} for each event,
    \makecounter{Btau}
  \item \label{pom-tau} \makecounter{tau}
    $\aTr{}{}:2^{\AllEvents}\fun\Formulae \fun\Formulae$ is a \emph{family of predicate transformers} over $\aEvs$, 
    \makecounter{Bterm}
  \item \label{pom-term} \makecounter{term}
    $\aTerm:\Formulae$ defines a \emph{termination condition},
    \makecounter{Bledep}
  \item \label{pom-ledep} \makecounter{ledep}
    ${\ledep} : (\Event\times\Event)$ is a partial order capturing \emph{dependency},
    \makecounter{Blesync}
  \item \label{pom-lesync} \makecounter{lesync}
    ${\lesync} : (\Event\times\Event)$ is a partial order capturing \emph{synchronization}, 
    \makecounter{Bleloc}
  \item \label{pom-leloc} \makecounter{leloc}
    ${\leloc} : (\Event\times\Event)$ is a partial order capturing \emph{per-location order}, such that 
    \begin{enumerate}
    \item \label{pom-leloc-lesync}
      if $\labeling(\bEv)\roverlaps\labeling(\aEv)$ 
      then $\bEv\lesync\aEv$ implies $\bEv\leloc\aEv$,      
    \end{enumerate}
    \makecounter{Brmw}
  \item \label{pom-rmw} \makecounter{rmw}
    ${\rrmw} : \Event\fun\Event$ is a partial function capturing read-modify-write \emph{atomicity}, such that
    \begin{enumerate}
    \item \label{pom-rmw-block}
      if $\bEv\xrmw\aEv$ then $\labeling(\aEv) \rblocks \labeling(\bEv)$,
    \item \label{pom-rmw-lesync} \label{pom-rmw-leloc}
      if $\bEv\xrmw\aEv$ then $\bEv \lesync \aEv$ and $\bEv \leloc \aEv$,    
    \item \label{pom-rmw-atomic}
      if $\labeling(\cEv)\roverlaps\labeling(\bEv)$ then
      \begin{enumerate}        
      \item \label{pom-rmw-atomic1}
        if $\bEv \xrmw \aEv$ then
        $\cEv\ledep \aEv$ implies $\cEv\ledep \bEv$,
        $\cEv\lesync \aEv$ implies $\cEv\lesync \bEv$,
        $\cEv\leloc \aEv$ implies $\cEv\leloc \bEv$,
      \item \label{pom-rmw-atomic2}
        if $\bEv \xrmw \aEv$ then
        $\bEv\ledep \cEv$ implies $\aEv\ledep \cEv$,
        $\bEv\lesync \cEv$ implies $\aEv\lesync \cEv$,
        $\bEv\leloc \cEv$ implies $\aEv\leloc \cEv$.
      \end{enumerate}
    \end{enumerate}
  \end{enumerate}

  % Let $\bEv\leexists\aEv$ when $\aEv\leloc\bEv$ implies $\bEv=\aEv$ and
  % $\labeling(\bEv) \rsoverlaps \labeling(\aEv)$ implies $\bEv\leloc\aEv$.
  % $\aEv\not\ltloc\bEv$ and if
  % $\labeling(\bEv) \rsoverlaps \labeling(\aEv)$ then $\bEv\leloc\aEv$.
  % \begin{math}
  %   \smash{\begin{cases}
  %     \bEv'\leloc\aEv' &\text{if}\; \bEv \rsmatches \aEv
  %     \\
  %     \aEv'\not\ltloc\bEv' &\text{otherwise}
  %   \end{cases}}
  % \end{math}

  A pomset is a \emph{candidate} if there is an injective relation
  ${\rrfx} : \Event\times\Event$, capturing \emph{reads-from}, such that
  \begin{enumerate}[,label=(\textsc{c}\arabic*),ref=\textsc{c}\arabic*]
    \setcounter{enumi}{\value{Blambda}}
  \item \label{cand-lambda}
    if $\bEv\xrfx\aEv$ then $\labeling(\bEv) \rmatches \labeling(\aEv)$,
    \setcounter{enumi}{\value{Bledep}}
  \item \label{cand-ledep-rf}
    if $\bEv\xrfx\aEv$ then $\bEv \ledep \aEv$,
    \setcounter{enumi}{\value{lesync}}
  \item[] 
    \begin{enumerate}[leftmargin=0pt]
    \item \label{cand-lesync-rf}
      if $\bEv'\lesync\bEv\xrfx\aEv\lesync\aEv'$ and $\labeling(\bEv') \rsmatches \labeling(\aEv')$ then $\bEv' \lesync \aEv'$,
    \item \label{cand-lesync-sc}
      if $\labeling(\bEv) \rsfences \labeling(\aEv)$ then either $\bEv\lesync\aEv$ or $\aEv\lesync\bEv$,
    \end{enumerate}
    \setcounter{enumi}{\value{leloc}}
  \item[] 
    \begin{enumerate}[leftmargin=0pt]
    \item  \label{cand-leloc-rf}
      if $\bEv\xrfx\aEv$ then $\bEv \leloc \aEv$,
    \item \label{cand-leloc-block}
      if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then either $\cEv\leexists\bEv$ or $\aEv\leexists\cEv$,\\
      where $\bEv'\leexists\aEv'$ when $\aEv'\leloc\bEv'$ implies $\bEv'=\aEv'$ and
      $\labeling(\bEv') \rsoverlaps \labeling(\aEv')$ implies $\bEv'\leloc\aEv'$.
    \end{enumerate}
  \end{enumerate}

  A candidate pomset with $\rrfx$ is \emph{top-level} if
  \begin{enumerate}[,label=(\textsc{t}\arabic*),ref=\textsc{t}\arabic*]
    \setcounter{enumi}{\value{Blambda}}
  \item \label{top-rf}
    if $\labeling(\aEv)$ is a $\sread$ then there is some $\bEv\xrfx\aEv$,
    \setcounter{enumi}{\value{Bkappa}}
  \item \label{top-kappa}
    $\labelingForm(\aEv)$ is a tautology (for every $\aEv\in\aEvs$),
    \setcounter{enumi}{\value{Bterm}}
  \item \label{top-term}
    $\aTerm$ is a tautology.
  \end{enumerate}
\end{definition}

Note that for the \IMM{} model, \ref{cand-leloc-block} is equivalent to:\footnote{If all accesses are morally strong with each other, weak fulfillment
  degenerates to
  \begin{center}
    $\forall\labelingAct(\cEv)=\DWP[]{x}{}$ either
    $\cEv \leloc \bEv$ or $\aEv \leloc \cEv$
  \end{center}

  If no accesses are morally strong with each other, weak fulfillment
  degenerates to
  \begin{center}
    $\not\mkern-5mu\exists\labelingAct(\cEv)=\DWP[]{x}{}$ 
    both $\bEv \ltloc \cEv$ and $\cEv \ltloc \aEv$
  \end{center}

  Note that the difference between strong and weak fulfillment is limited to $\leloc$.
  We sometimes write $\lelocstrong$ for strong fulfillment and
  $\lelocweak$ for weak fulfillment.}
\begin{center}
  if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then
  either $\cEv\leloc\bEv$ or $\aEv\leloc\cEv$.
\end{center}

% Define $\leexists$ as follows.
% \begin{align*}
%   \bEv\leexists\aEv &\textwhen                      
%   \begin{cases}
%     \bEv\leloc\aEv &\text{if}\; \bEv \;\text{is morally strong with}\; \aEv
%     \\
%     \aEv\not\ltloc\bEv &\text{otherwise}
%   \end{cases}
% \end{align*}    
% A read event $\aEv$ is \emph{strongly fulfilled} if there is a
% $\bEv\xrfx\aEv$ and 
% \begin{center}
%   for any $\cEv$ that can block $\aEv$, either $\cEv\leloc\bEv$ or
%   $\aEv\leloc\cEv$.
% \end{center}
% A read event $\aEv$ is \emph{weakly fulfilled} if there is a
% $\bEv\xrfx\aEv$ and 
% \begin{center}
%   for any $\cEv$ that can block $\aEv$, either $\cEv\leexists\bEv$ or
%   $\aEv\leexists\cEv$.
% \end{center}




Let $\aPS$ range over pomsets, and $\aPSS$ over sets of pomsets.

We lift terminology from actions to events.  For example, we say that $\aEv$
writes $\aLoc$ if $\labeling(\aEv)$ writes $\aLoc$.  We also drop quantifiers
when clear from context, such as
$(\forall\aEv\in\Event)(\forall\aLoc\in\Loc)$.
We write $\bEv\ltsync\aEv$ when $\bEv\lesync\aEv$ and $\bEv\neq\aEv$, and similarly
for $\ltdep$ and $\ltloc$.

\subsection{Semantics}

\input{fig-sem.tex}

See \reffig{fig:sem}.

In diagrams, we use different shapes and colors for arrows and events.  These
are included only to help the reader understand why order is included.  We
adopt the following conventions:
\begin{itemize}  
\item \makebox{$\aEv\xpo\bEv$} arises from control/data/address \emph{dependency} \eqref{seq-kappa},
\item \makebox{$\aEv\xsync\bEv$} arises from $\rsyncdelaysdef$ \eqref{seq-delay-sync},
\item \makebox{$\aEv\xwki\bEv$} arises from $\rcodelaysdef$ \eqref{seq-delay-co},
\item \makebox{$\aEv\xrf\bEv$} arises from \emph{matching}
  \eqref{cand-ledep-rf}, \eqref{cand-lesync-rf} and \eqref{cand-leloc-rf},
\item \makebox{$\aEv\xsyncsc\bEv$} arises from \emph{strong fencing} \eqref{cand-lesync-sc},
\item \makebox{$\aEv\xwk\bEv$} arises from \emph{blocking} \eqref{cand-leloc-block}.
\end{itemize}

\begin{definition}
  \label{def:semaddr}
  Address Calculation.

  \noindent
  If $\aPS \in \sSTORE[\amode]{\cExp}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\cVal\in\Val)$
  $(\exists\aVal\in\Val)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
    \item \label{write-E-addr}
      if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
    \item \label{write-lambda-addr}
      $\labelingAct(\aEv) = \DW[\amode]{\REF{\cVal}}[\ascope]{\aVal}[\aThrd]$,
    \item \label{write-kappa-addr}
      \begin{math}
        \labelingForm(\aEv) \rimplies
        \cExp{=}\cVal
        \land \aExp{=}\aVal
      \end{math},      
    \item[] \setcounter{enumi}{\value{tau}} \labeltextX{4}{w}{write-tau-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-tau-dep-addr}
        if $\aEvs\neq\emptyset$ then 
        \begin{math}
          \aTr{\bEvs}{\bForm} \rimplies 
          (\cExp{=}\cVal)
          \limplies 
          \bForm[\aExp/\REF{\cVal}]
        \end{math},
      \item \label{write-tau-empty-addr}
        if $\aEvs=\emptyset$ then \\
        \begin{math}
          (\forall\dVal)
        \end{math}        
        \begin{math}
          \aTr{\bEvs}{\bForm} \rimplies 
          (\cExp{=}\dVal)
          \limplies 
          \bForm
          [\aExp/\REF{\dVal}]
        \end{math}  
      \end{enumerate}  
      \stepcounter{enumi}
    \item[] \labeltextX{5}{w}{write-term-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-term-nonempty-addr}
        if $\aEvs\neq\emptyset$ then $\aTerm \rimplies \cExp{=}\cVal \land \aExp{=}\aVal$,
      \item \label{write-term-empty-addr}
        if $\aEvs=\emptyset$ then $\aTerm \rimplies \FALSE$.
      \end{enumerate}
    \end{enumerate}
  \end{multicols}

  \medskip
  \noindent
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\cExp}[\aThrd]$ then
  $(\exists\cVal\in\Val)$
  $(\exists\aVal\in\Val)$
  \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  \item \label{read-E-addr}
    if $\bEv,\aEv\in\aEvs$ then $\bEv=\aEv$,
  \item \label{read-lambda-addr}
    $\labelingAct(\aEv) = \DR[\amode]{\REF{\cVal}}[\ascope]{\aVal}[\aThrd]$
  \item \label{read-kappa-addr}
    \begin{math}
      \labelingForm(\aEv) 
      \land \cExp{=}\cVal
    \end{math},
    \stepcounter{enumi}
  \item[] \labeltextX{4}{r}{read-tau-addr}
    \begin{enumerate}[leftmargin=0pt]
    \item \label{read-tau-dep-addr}
      \begin{math}
        (\forall\aEv\in\aEvs\cap\bEvs)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        (\cExp{=}\cVal\limplies\aVal{=}\uReg{\aEv})
        \limplies \bForm[\uReg{\aEv}/\aReg]
      \end{math},      
    \item \label{read-tau-ind-addr}
      \begin{math}
        (\forall\aEv\in\aEvs\setminus\bEvs)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        \PBR{(\cExp{=}\cVal\limplies\aVal{=}\uReg{\aEv}) \lor (\cExp{=}\cVal\limplies\REF{\cVal}{=}\uReg{\aEv})}
        \limplies
        \bForm[\uReg{\aEv}/\aReg]
      \end{math},      
    \item \label{read-tau-empty-addr}
      \begin{math}
        (\forall\bReg)
      \end{math}
      if $\aEvs=\emptyset$ then 
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies 
        \bForm[\bReg/\aReg],
      \end{math}  
    \end{enumerate}  
  \item \label{read-term-addr}
    if $\aEvs=\emptyset$ and $\amode\neq\mRLX$ then $\aTerm \rimplies \FALSE$. 
  \end{enumerate}
\end{definition}


\begin{definition}
  \label{def:semca}
  If-closure
  
  \noindent
  If $\aPS \in \sSTORE[\amode]{\aLoc}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
    \item \label{write-E-ca}
      if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
    \item \label{write-lambda-ca}
      $\labelingAct(\aEv) = \DW[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$,
    \item \label{write-kappa-ca}
      \begin{math}
        \labelingForm(\aEv) \rimplies
        \cForm_\aEv
        \land \aExp{=}\aVal_\aEv
      \end{math},        
    \item \label{write-tau-ca}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies 
        \cForm_\aEv
        \limplies 
        \bForm[\aExp/\aLoc]
      \end{math},
    \item \label{write-term-ca}
      $\aTerm \rimplies \cForm_\aEv \limplies \aExp{=}\aVal_\aEv$,
    \end{enumerate}
  \end{multicols}

  \medskip
  \noindent
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\aLoc}[\aThrd]$ then
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$ 
  \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  \item \label{read-E-ca}
    if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{read-lambda-ca}
    $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  \item \label{read-kappa-ca}
    \begin{math}
      \labelingForm(\aEv) \rimplies
      \cForm_\aEv
    \end{math},
    \stepcounter{enumi}
  \item[] \labeltextX{4}{r}{read-tau-ca}
    \begin{enumerate}[leftmargin=0pt]
    \item \label{read-tau-dependent-ca}
      \begin{math}
        (\forall\aEv\in\aEvs\cap\bEvs)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        \cForm_\aEv
        \limplies \aVal_\aEv{=}\uReg{\aEv}
        \limplies \bForm[\uReg{\aEv}/\aReg]
      \end{math},
      
    \item \label{read-tau-independent-ca}
      \begin{math}
        (\forall\aEv\in\aEvs\setminus\bEvs)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        \cForm_\aEv 
        \limplies
        \PBR{\aVal_\aEv{=}\uReg{\aEv} \lor \aLoc{=}\uReg{\aEv}}
        \limplies
        \bForm[\uReg{\aEv}/\aReg]
      \end{math},
      
    \item \label{read-tau-empty-ca}
      \begin{math}
        (\forall\bReg)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies 
        (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies 
        \bForm[\bReg/\aReg],
      \end{math}  
    \end{enumerate}  
  \item \label{read-term-ca}
    if $\aEvs=\emptyset$ and $\amode\neq\mRLX$ then $\aTerm \rimplies \FALSE$. 
  \end{enumerate}
\end{definition}
\begin{definition}
  \label{def:semcaaddr}
  Both.
  
  \noindent
  If $\aPS \in \sSTORE[\amode]{\cExp}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\cVal:\aEvs\fun\Val)$
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
    \item \label{write-E-ca-addr}
      if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
    \item \label{write-lambda-ca-addr}
      $\labelingAct(\aEv) = \DW[\amode]{\REF{\cVal}}[\ascope]{\aVal_\aEv}[\aThrd]$,
    \item \label{write-kappa-ca-addr}
      \begin{math}
        \labelingForm(\aEv) \rimplies
        \cForm_\aEv
        \land \cExp{=}\cVal_\aEv
        \land \aExp{=}\aVal_\aEv
      \end{math},      
      \stepcounter{enumi}
    \item[] \labeltextX{4}{w}{write-tau-ca-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-tau-dep-ca-addr}
        \begin{math}
          \aTr{\bEvs}{\bForm} \rimplies 
          \cForm_\aEv
          \limplies (\cExp{=}\cVal)
          \limplies 
          \bForm[\aExp/\REF{\cVal}]
        \end{math},
      \item \label{write-tau-empty-ca-addr}
        \begin{math}
          (\forall\dVal)
        \end{math}
        \\
        \begin{math}
          \aTr{\bEvs}{\bForm} \rimplies 
          (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
          \limplies (\cExp{=}\dVal)
          \limplies 
          \bForm
          [\aExp/\REF{\dVal}]
        \end{math}  
      \end{enumerate}  
      \stepcounter{enumi}
    \item[] \labeltextX{5}{w}{write-term-ca-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-term-nonempty-ca-addr}
        $\aTerm \rimplies \cForm_\aEv \limplies \cExp{=}\cVal_\aEv \land \aExp{=}\aVal_\aEv$,
      \item \label{write-term-empty-ca-addr}
        $\aTerm \rimplies \bigvee_{\aEv\in\aEvs}\cForm_\aEv$.
      \end{enumerate}
    \end{enumerate}
  \end{multicols}

  \medskip
  \noindent
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\cExp}[\aThrd]$ then
  $(\exists\cVal:\aEvs\fun\Val)$
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$ 
  \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  \item \label{read-E-ca-addr}
    if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{read-lambda-ca-addr}
    $\labelingAct(\aEv) = \DR[\amode]{\REF{\cVal}}[\ascope]{\aVal_\aEv}[\aThrd]$
  \item \label{read-kappa-ca-addr}
    \begin{math}
      \labelingForm(\aEv) \rimplies
      \cForm_\aEv
      \land \cExp{=}\cVal_\aEv
    \end{math},
    \stepcounter{enumi}
  \item[] \labeltextX{4}{r}{read-tau-ca-addr}
    \begin{enumerate}[leftmargin=0pt]
    \item \label{read-tau-dependent-ca-addr}
      \begin{math}
        (\forall\aEv\in\aEvs\cap\bEvs)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        \cForm_\aEv
        \limplies (\cExp{=}\cVal_\aEv\limplies\aVal_\aEv{=}\uReg{\aEv})
        \limplies \bForm[\uReg{\aEv}/\aReg]
      \end{math},      
    \item \label{read-tau-independent-ca-addr}
      \begin{math}
        (\forall\aEv\in\aEvs\setminus\bEvs)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies
        \cForm_\aEv 
        \limplies
        \PBR{(\cExp{=}\cVal_\aEv\limplies\aVal_\aEv{=}\uReg{\aEv}) \lor (\cExp{=}\cVal_\aEv\limplies\REF{\cVal}{=}\uReg{\aEv})}
        \limplies
        \bForm[\uReg{\aEv}/\aReg]
      \end{math},      
    \item \label{read-tau-empty-ca-addr}
      \begin{math}
        (\forall\bReg)
      \end{math}
      \begin{math}
        \aTr{\bEvs}{\bForm} \rimplies 
        (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies 
        \bForm[\bReg/\aReg],
      \end{math}  
    \end{enumerate}  
  \item \label{read-term-ca-addr}
    if $\aEvs=\emptyset$ and $\amode\neq\mRLX$ then $\aTerm \rimplies \FALSE$. 
  \end{enumerate}
\end{definition}

\begin{definition}
  Let $\sLOADP{}{}$ be defined as for $\sLOAD{}{}$, adding the constraint:
  \begin{itemize}
  \item[{\labeltextXX{4d}{r}{read-tau-rmw}}]
    if $(\aEvs\cap\bEvs)=\emptyset$ then
    \begin{math}
      \aTr{\bEvs}{\bForm} \rimplies
      \bForm.
    \end{math}
  \end{itemize}
  If $\aPS\in\mathit{FADD}(\aReg,\cExp,\aExp,\amode,\bmode)$ then
  $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode]{\aReg}{\cExp}}{\sSTORE[\bmode]{\cExp}{\aReg{+}\aExp}})$
  \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
    $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
    $\bEv\xrmw\aEv$.
  \end{enumerate}
  If $\aPS\in\mathit{EXCHG}(\aReg,\cExp,\aExp,\amode,\bmode)$ then
  $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode]{\aReg}{\cExp}}{\sSTORE[\bmode]{\cExp}{\aExp}})$
  \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
    $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
    $\bEv\xrmw\aEv$.
  \end{enumerate}
  If $\aPS\in\mathit{CAS}(\aReg,\cExp,\aExp,\bExp,\amode,\bmode)$ then
  $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode]{\aReg}{\cExp}}{\sIF{\aReg{=}\aExp}\sTHEN\sSTORE[\bmode]{\cExp}{\bExp}\sELSE\sSKIP\sFI})$
  \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
    $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
    $\bEv\xrmw\aEv$.
  \end{enumerate}
\end{definition}


\section{Observational Refinement}

\begin{lemma}
  % $\sSEMI{\sSEMI{\aPSS_1}{\aPSS_2}}{\aPSS_3}=\sSEMI{\aPSS_1}{\sSEMI{\aPSS_2}{\aPSS_3}}$
  $(\aPSS_1\SEMI\aPSS_2)\SEMI\aPSS_3=\aPSS_1\SEMI(\aPSS_2\SEMI\aPSS_3)$
  and    
  $\sSEMIX{\aPSS}{\sSKIP}=\aPSS=\sSEMIX{\sSKIP}{\aPSS}$.

  % $\sLPAR{\sLPAR{\aPSS_1}{\aPSS_2}}{\aPSS_3}=\sLPAR{\aPSS_1}{\sLPAR{\aPSS_2}{\aPSS_3}}$
  $(\aPSS_1\LPAR\aPSS_2)\LPAR\aPSS_3=\aPSS_1\LPAR(\aPSS_2\LPAR\aPSS_3)$
  and    
  $\sLPARX{\aPSS}{\sSKIP}=\aPSS$.  

  \vspace{-.5\baselineskip}
  \begin{proof}
    Straightforward calculation.  Associativity of $\SEMI\!$ requires
    disjunction closure \eqref{tr-or}.
  \end{proof}
\end{lemma}
\begin{definition}
  \label{def:augment}
  $\aPS_2$ is an \emph{augment} of $\aPS_1$ if
  \begin{multicols}{3}
    \begin{enumerate}
    \item $\aEvs_2=\aEvs_1$,
    \item $\labelingAct_2(\aEv)=\labelingAct_1(\aEv)$,
    \item $\labelingForm_2(\aEv) \rimplies \labelingForm_1(\aEv)$,
    \item $\aTr[2]{\bEvs}{\bForm} \rimplies \aTr[1]{\bEvs}{\bForm}$,
    \item $\aTerm[2] \rimplies \aTerm[1]$,
    \item ${\ledep_2}\supseteq{\ledep_1}$,
    \item ${\lesync_2}\supseteq{\lesync_1}$,
    \item ${\leloc_2}\supseteq{\leloc_1}$,
    \item ${\rrmw_2}\supseteq{\rrmw_1}$.
    \end{enumerate}
  \end{multicols}
\end{definition}
\begin{lemma}
  % Suppose $\aPS_1\in\sem{\aCmd}$.
  If $\aPS_1\in\sem{\aCmd}$ and $\aPS_2$  augments $\aPS_1$ then $\aPS_2\in\sem{\aCmd}$.
  % \item If $\aPS_2$ is a downset of $\aPS_1$ then $\aPS_2\in\sem{\aCmd}$.
  % \end{lemma}

  \vspace{-.5\baselineskip}
  \begin{proof}
    Induction on the definition of $\sem{}$.
  \end{proof}
\end{lemma}


% A \emph{test}, $\aTest$, is statement that may write location $0$. 
% A \emph{user program}, $\aUser$, is a statement that never writes location $0$.
% We define an equivalence using may-testing.  Let $\testThrd$ be a
% distinguished thread id for tests.  We require that $\testThrd$ does not
% appear in commands.

\begin{definition}  
  Let $\pass{\aPS_1}{\aPS_2}$ if there is some top-level pomset in
  $\sLPAR{\aPS_1}{\aPS_2}$.

  Let $\aPSS_1\suptesteq\aPSS_2$ if $(\forall\aPS_2\in\aPSS_2)$
  $(\exists\aPS_1\in\aPSS_1)$  %$(\forall\bForm)$ $(\forall\aTest)$:
  such that 
  $\aTr[1]{}{\bForm} \rimplies \aTr[2]{}{\bForm}$ and
  $(\forall\aPS_3)$ 
  $\pass{\aPS_1}{\aPS_3}$ implies $\pass{\aPS_2}{\aPS_3}$.

  Let $\aPSS_1\suptest\aPSS_2$ if $\aPSS_1\suptesteq\aPSS_2$ and $\aPSS_2\not\suptesteq\aPSS_1$.

  % Let $\aPSS_1\ncomptest\aPSS_2$ if $\aPSS_1\not\suptesteq\aPSS_2$ and $\aPSS_2\not\suptesteq\aPSS_1$.

  Let $\aPSS_1\eqtest\aPSS_2$ if $\aPSS_1\suptesteq\aPSS_2$ and $\aPSS_2\suptesteq\aPSS_1$.
\end{definition}

Equivalently, we could distinguish the test pomset $\aPS_3$, allowing only it
to dereference location $0$, and require the top-level pomset in
$\sLPAR{\aPS_1}{\aPS_2}$ to include an action $\DWP{\REF{0}}{}$.  We use this
formulation in examples.
%$\labeling(\aEv')=\DWP{\REF{0}}{}$.

For example,
\begin{math}
  \sem{\PW{x}{1}\SEMI\PW{x}{1}}\suptest\sem{\PW{x}{1}}.
\end{math}
These are distinguished by the test:
\begin{gather*}
  \PR{x}{r} \SEMI
  \PW{x}{2} \SEMI
  \PR{x}{s}\SEMI
  \IF{\aReg {=} \bReg} \THEN \PW{\REF{0}}{1} \FI
  \\
  \tag{$\leloc$}
  \hbox{\begin{tikzinline}[node distance=1.5em]
      \event{a1}{\DR{x}{1}}{}
      \event{a2}{\DW{x}{2}}{right=of a1}
      \event{a3}{\DR{x}{1}}{right=of a2}
      \event{a4}{\DW{\REF{0}}{1}}{right=of a3}
      \wki{a1}{a2}
      \wki{a2}{a3}
    \end{tikzinline}}
\end{gather*}
This can be fulfilled by $\sem{\PW{x}{1}\SEMI\PW{x}{1}}$, but not $\sem{\PW{x}{1}}$.

Due to the requirement on predicate transformers, observational refinement is
sensitive to register names:
% \begin{math}
%   \sem{\PR{x}{r}}\not\suptesteq\sem{\PR{x}{s}}.
% \end{math}
% We also have
\begin{math}
  \sem{\SKIP}\suptest\sem{\LET{r}{1}}.
\end{math}
These are distinguished by the precondition
$\bForm=(r{=}1)$.

On the other hand,
\begin{math}
  \sem{\PR{x}{r}\SEMI\PR{x}{r}}\eqtest\sem{\PR{x}{r}}.
\end{math}

\begin{lemma}
  If $\aPSS_1\supseteq\aPSS_2$ then $\aPSS_1\suptesteq\aPSS_2$.
\end{lemma}

Define contexts as follows.
\begin{align*}
  \aCtxt
  \BNFDEF& \hole{}
  \BNFSEP \IF{\aExp} \THEN \aCtxt \ELSE \aCmd \FI
  \BNFSEP \IF{\aExp} \THEN \aCmd \ELSE \aCtxt \FI
  \BNFSEP \aCtxt \SEMI \aCmd
  \BNFSEP \aCmd \SEMI \aCtxt
  \BNFSEP \aCtxt \LPAR[\bThrd] \aCmd
  \BNFSEP \aCmd \LPAR[\bThrd] \aCtxt
\end{align*}
\begin{lemma}
  If $\sem{\aCmd_1}\suptesteq\sem{\aCmd_2}$ then $\sem{\aCtxt\hole{\aCmd_1}}\suptesteq\sem{\aCtxt\hole{\aCmd_2}}$.
\end{lemma}


\section{Merge}
Let
$\fmerge{}{}:\Act\times\Act\fun2^{\Act}$
be defined as follows.
Let
\begin{math}
  \fmerge{\DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]}{\DR[\bmode]{\aLoc}[\bscope]{\aVal}[\aThrd]} = \{
  \DR[\amode\lubmode\bmode]{\aLoc}[\ascope\lubscope\bscope]{\aVal}[\aThrd] \}
\end{math},
\begin{math}
  \fmerge{\DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]}{\DW[\bmode]{\aLoc}[\bscope]{\aVal}[\aThrd]} = \{
  \DW[\amode\lubmode\bmode]{\aLoc}[\ascope\lubscope\bscope]{\aVal}[\aThrd] \}
\end{math},
\begin{math}
  \fmerge{\DW[\amode]{\aLoc}[\ascope]{\aVal}}{\DR[\bmode\lemode\mRLX]{\aLoc}[\bscope\lescope\ascope]{\aVal}[\aThrd]} = \{
  \DW[\amode\lubmode\bmode]{\aLoc}[\ascope]{\aVal}[\aThrd] \}
\end{math},
\begin{math}
  \fmerge{\DF[\ascope]{\amode}[\aThrd]}{\DF[\bscope]{\bmode}[\aThrd]} = \{ \DF [\ascope\lubscope\bscope]{\amode\lubmode\bmode}[\aThrd] \}
\end{math},
and
\begin{math}
  \fmerge{\aAct}{\bAct} = \emptyset, 
\end{math}
otherwise.

If $\aAct_0\in\fmerge{\aAct_1}{\aAct_2}$, then $\aAct_1$ and $\aAct_2$ can
coalesce, resulting in $\aAct_0$.  This allows optimizations such as
$(\PW{x}{1}\SEMI \PW{x}{2})$ to $(\PW{x}{2})$ and
$(\PW{x}{1}\SEMI \PR{x}{r})$ to $(\PW{x}{1}\SEMI \PR{1}{r})$.  For
associativity of sequential composition, it is important that $\fmerge{}{}$
always take an upper bound on the modes of the two actions.  For example, it
would invalidate associativity to allow
$\DWP{\aLoc}{\aVal}\in\fmerge{\DW{\aLoc}{\aVal}}{\DR[\mACQ]{\aLoc}{\aVal}}$,
although this is considered safe.\footnote{A list of safe merge operations
  can be found in \cite[\textsection E]{DBLP:conf/cgo/ChakrabortyV17} and
  \cite[\textsection7.1]{Kang19}.  For examples of unsafe merges and
  reorderings, see \cite[\textsection D]{DBLP:conf/cgo/ChakrabortyV17}.}

\begin{enumerate}[topsep=0pt,label=(\textsc{s}\arabic*),ref=\textsc{s}\arabic*]
\item[] \setcounter{enumi}{\value{lambda}} \labeltextX{2}{s}{seq-lambda-merge}
  \begin{enumerate}[leftmargin=0pt]
  \item \label{seq-lambda-merge1}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labeling(\aEv)=\labeling_1(\aEv)$,
  \item \label{seq-lambda-merge2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labeling(\aEv)=\labeling_2(\aEv)$,
  \item \label{seq-lambda-merge12}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labeling(\aEv)\in \fmerge{\labeling_1(\aEv)}{\labeling_2(\aEv)}$,
  \end{enumerate}
\end{enumerate}


\endinput
\subsection{Generalized access modes}
This is an option.

\begin{displaymath}
  \begin{tikzpicture}
    \node (wk)  at (-1, 0) {$\mathstrut\mWK$};
    \node (rlx) at (0, 0) {$\mathstrut\mRLX$};
    \node (ra)  at (1, 0) {$\mathstrut\mRA$};
    \node (sc)  at (2, 0) {$\mathstrut\mSC$};
    \node (fsc) at (3, 0) {$\mathstrut\fSC$};
    \node (rel) at (2, -0.3) {$\mathstrut\fREL$};
    \node (acq) at (2,  0.3) {$\mathstrut\fACQ$};
    \draw[->](wk)to(rlx);
    \draw[->](rlx)to(ra);
    \draw[->](ra)to(sc);
    \draw[->](ra)to(rel);
    \draw[->](ra)to(acq);
    \draw[->](sc)to(fsc);
    \draw[->](rel)to(fsc);
    \draw[->](acq)to(fsc);
  \end{tikzpicture}
\end{displaymath}
\begin{align*}
  \fmerge{\DF{\amode}}{\DR[\bmode]{\aLoc}{\aVal}}
  = \fmerge{\DR[\amode]{\aLoc}{\aVal}}{\DF{\bmode}}
  &= \{ \DR[\amode\lubmode\bmode]{\aLoc}{\aVal} \}
  \\
  \fmerge{\DF{\amode}}{\DW[\bmode]{\aLoc}{\bVal}}
  = \fmerge{\DW[\amode]{\aLoc}{\bVal}}{\DF{\bmode}}
  &= \{ \DW[\amode\lubmode\bmode]{\aLoc}{\bVal} \}
\end{align*}
\begin{scope}
  \begin{align*}
    {\reorderra}
    &=
    \{(\DW[\amode]{}{}, \DR[\bmode]{}{}) \mid \amode\not\gemode\mSC \lor \bmode\not\gemode\mSC\}
    \cup\{(\DW[\amode]{}{}, \DW[\mRLX]{}{} \mid \amode\not\gemode\fREL \}
    \\&
    \cup\{(\DR[\amode]{}{}, \DW[\bmode]{}{}) \mid \amode=\mRLX \land \bmode=\mRLX\}
    \cup\{(\DR[\mRLX]{}{},  \DR[\bmode]{}{}) \mid \bmode\not\gemode\fACQ \}
    \\&
    \cup\{(\DF{\fREL},      \DF{\fACQ}    ) \}
    \cup\{(\DF{\fREL},      \DR[\bmode]{}{}) \}%\mid \amode=\fREL \}
    \cup\{(\DW[\amode]{}{}, \DF{\fACQ}     ) \}%\mid \bmode=\fACQ \}
  \end{align*}  
\end{scope}
In terms of reordering, $\DF{\fREL}$ is the same as $\DW[\fREL]{}{}$, and
$\DF{\fACQ}$ is the same as $\DR[\fACQ]{}{}$.
\begin{center}
  \setlength{\tabcolsep}{4pt}
  \begin{tabular}{c|ccccc|ccccc}
    &  \multicolumn{9}{|c}{$2^{\text{nd}}$} \\
    \hline
    $1^{\text{st}}$
    & $\DR[\mRLX]{}{}$  & $\DR[\mACQ]{}{}$ & $\DR[\fACQ]{}{}$& $\DR[\mSC]{}{}$  & $\DR[\fSC]{}{}$ & $\DW[\mRLX]{}{}$& $\DW[\mREL]{}{}$ & $\DW[\fREL]{}{}$& $\DW[\mSC]{}{}$& $\DW[\fSC]{}{}$\\% & $\DF{\fREL}$&$\DF{\fACQ}$ &$\DF{\fSC}$\\
    \hline                                                                                                                                                                                                                            
    $\DR[\mRLX]{}{}$ & \cmark            & \cmark          & \xmark          & \cmark           & \xmark           & \cmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\xmark       & \xmark    \\
    $\DR[\mACQ]{}{}$  & \xmark            & \xmark          & \xmark          & \xmark           & \xmark           & \xmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\xmark       & \xmark    \\
    $\DR[\fACQ]{}{}$ & \xmark            & \xmark          & \xmark          & \xmark           & \xmark           & \xmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\xmark       & \xmark    \\
    $\DR[\mSC]{}{}$  & \xmark            & \xmark          & \xmark          & \xmark           & \xmark           & \xmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\xmark       & \xmark    \\
    $\DR[\fSC]{}{}$ & \xmark            & \xmark          & \xmark          & \xmark           & \xmark           & \xmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\xmark       & \xmark    \\
    \hline                                                                                                                                                                                                                           
    $\DW[\mRLX]{}{}$ & \cmark            & \cmark          & \cmark          & \cmark           & \xmark           & \cmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\cmark       & \xmark    \\
    $\DW[\mREL]{}{}$  & \cmark            & \cmark          & \cmark          & \cmark           & \xmark           & \cmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\cmark       & \xmark    \\
    $\DW[\fREL]{}{}$ & \cmark            & \cmark          & \cmark          & \cmark           & \xmark           & \xmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\cmark       & \xmark    \\
    $\DW[\mSC]{}{}$  & \cmark            & \cmark          & \cmark          & \xmark           & \xmark           & \cmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\cmark       & \xmark    \\
    $\DW[\fSC]{}{}$ & \xmark            & \xmark          & \xmark          & \xmark           & \xmark           & \xmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\cmark       & \xmark    \\
  \end{tabular}
\end{center}

