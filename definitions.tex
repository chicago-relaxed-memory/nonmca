% r=x; x=r; s=x; 
% ||
% x=1; x=2

% Quiensence with x=1
% W1 R1 W1 W2

%\section{Notes}
% GPU stuff:
% \begin{itemize}
% \item Vulcan/Alloy
% \item OpenCL
% \item AMD PTX
% \item Matthew Sinclair/Sarita Adve stuff ``Chasing Away RAts- Semantics and
%   Evaluation for Relaxed Atomics on Heterogeneous Systems'' and his thesis
% \end{itemize}

\section{Model}
\label{sec:model}

\subsection{Preliminaries}
\label{sec:prelim}
The syntax is built from
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$, $\bVal$, $\cVal$, $\dVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$, $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$,  $\cExp$,
\item a set of \emph{thread \ID{}s} $\Thrd$, ranged over by
  $\aThrd$, $\bThrd$.
\end{itemize}

\emph{Memory references} are tagged values, written $\REF{\cVal}$.  Let $\Loc$
be the set of memory references, ranged over by $\aLoc$, $\bLoc$, $\cLoc$.
We require that:
\begin{itemize}
\item values and registers are disjoint, 
\item values include at least the constants $0$ and $1$,  
\item expressions include at least registers and values, 
\item references do not appear in expressions: $\aExp[\bExp/\aLoc]=\aExp$,
\item thread \ID{}s include the \emph{top-level} \ID{} $\topThrd$. % and the \emph{test} id $\testThrd$. 
\end{itemize}
We model the following language (defaults underlined).
\begin{gather*}
  \begin{aligned}
    \amode,\bmode \BNFDEF& \mWK
    \BNFSEP \underline{\mRLX}
    \BNFSEP \mREL
    \BNFSEP \mACQ
    \BNFSEP \mRA 
    \BNFSEP \mSC
    % &
    % \fmode \BNFDEF& \fACQ 
    % \BNFSEP \fREL
    % \BNFSEP \fSC
    &\qquad \qquad
    \ascope,\bscope \BNFDEF& \sCTA
    \BNFSEP \sGPU
    \BNFSEP \underline{\smash{\sSYS}}
  \end{aligned}
  \\
  \begin{aligned}
    \aCmd%,\aTest
    \BNFDEF& \SKIP
    \BNFSEP \LET{\aReg}{\aExp}
    \BNFSEP \PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}
    \BNFSEP \PW[\amode]{\REF{\cExp}}[\ascope]{\aExp}
    \BNFSEP \PF[\ascope]{\fmode}
    \BNFSEP \IF{\aExp} \THEN \aCmd_1 \ELSE \aCmd_2 \FI
    \BNFSEP \aCmd_1 \SEMI \aCmd_2
    \\[-.5ex]
    \BNFSEP& \aCmd_1 \RPAR[\bThrd] \aCmd_2
    \BNFSEP \PCAS[\amode][\bmode]{\REF{\cExp}\,}[\ascope]{\aReg}{\aExp}{\bExp}
    \BNFSEP \PFADD[\amode][\bmode]{\REF{\cExp}\,}[\ascope]{\aReg}{\aExp}
    \BNFSEP \PEXCHG[\amode][\bmode]{\REF{\cExp}\,}[\ascope]{\aReg}{\aExp}
    % \BNFSEP \PCAS[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}{\bExp}
    % \BNFSEP \PFADD[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
    % \BNFSEP \PEXCHG[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
  \end{aligned}
\end{gather*}
% \emph{Access modes}, $\amode$, are {weak} ($\mWK$), are {relaxed} ($\mRLX$),
% {release-acquire} ($\mRA$), and {sequentially consistent} ($\mSC$).
% $\mRA$/$\mSC$ accesses are collectively known as \emph{synchronized
% accesses}.
% % 
% \emph{Fence modes}, $\bmode$, are {acquire} ($\fACQ$), {release} ($\fREL$), 
% and {acquire-release} ($\fSC$).  

\emph{Access modes}, $\amode$, are {weak} ($\mWK$), {relaxed} ($\mRLX$),
{release} ($\mREL$), {acquire} ($\mACQ$), {release-acquire} ($\mRA$), and
{sequentially consistent} ($\mSC$).
% 
In examples, we systematically drop the default mode $\mRLX$.
%
% 
Reads ($\PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}$) support
$\mWK$,
$\mRLX$,
% $\mREL$,
$\mACQ$,
% $\mRA$, 
$\mSC$. 
Writes ($\PW[\amode]{\REF{\cExp}}[\ascope]{\aReg}$) support
$\mWK$,
$\mRLX$,
$\mREL$,
% $\mACQ$,
% $\mRA$, 
$\mSC$. 
Fences ($\PF[\ascope]{\fmode}$) support
% $\mWK$,
% $\mRLX$,
$\mREL$,
$\mACQ$,
$\mRA$, 
$\mSC$.
% 
In the atomic update operations, $\amode$ is a read and $\bmode$ is a write;
we require that $\aReg$ does not occur in $\cExp$.
%
Let expressions ($\LET{\aReg}{\aExp}$) only affect thread-local state and
thus do not have a mode.

\emph{Statements}, $\aCmd$, include memory accesses at a
given mode, as well as the usual structural constructs.  Following
\cite{DBLP:conf/icfp/FerreiraHJ96}, $\RPAR$ denotes parallel composition.  If
$(\aCmd_1 \RPAR[\bThrd] \aCmd_2)$ is executed with thread \ID{} $\aThrd$, then
$\aCmd_1$ runs with \ID{} $\bThrd$ and $\aCmd_2$ continues under \ID{} $\aThrd$.
Top level programs run with thread \ID{} $\topThrd$.  In examples, we usually
drop thread \ID{}s.  We use the symmetric $\PAR$ operator when there is no
continuation after the parallel composition.

\emph{Scopes}, $\ascope$, are thread group ($\sCTA$), processor ($\sGPU$) and
system ($\sSYS$).
%
In examples, we systematically drop the default scope $\sSYS$.
% 
Let $\PBR{\xsys}=(\Thrd\times\Thrd)$.  We assume two equivalences:
$\PBR{\xgpu}\subseteq\PBR{\xsys}$ partitions threads by \emph{processor}, and
$\PBR{\xcta}\subseteq\PBR{\xgpu}$ refines the processor partitioning into
\emph{thread groups}.
%
In examples, we mostly elide thread \ID{}s and ignore the $\sGPU$ scope.  We
write $(\aCmd_1\RPAR[\ascope]\aCmd_2)$ to indicate that the statements run in
threads related by $=_\ascope$, but not by any $=_\bscope$ for
$\bscope\ltscope\ascope$.  In the following examples, let $\aThrd$ be \ID{}
of the rightmost thread.  Then $(\aCmd_1\RPAR[\sCTA]\aCmd_2)$ is shorthand
for $(\exists\bThrd\xcta\aThrd)$ $(\aCmd_1\RPAR[\bThrd]\aCmd_2)$.  When using
this convention, $\RPAR$ associates to the left; thus,
$(\aCmd_1\RPAR[\sCTA]\aCmd_2\RPAR[\sSYS]\aCmd_3)$ is read as
$((\aCmd_1\RPAR[\sCTA]\aCmd_2)\RPAR[\sSYS]\aCmd_3)$, which is
$(\exists\bThrd\xcta\cThrd\not\xcta\aThrd)$
$(\aCmd_1\RPAR[\bThrd]\aCmd_2\RPAR[\cThrd]\aCmd_3)$.  When there is no
continuation, we further simplify $\aCmd_1\RPAR[\ascope]\aCmd_2$ to
$\aCmd_1\PAR[\ascope]\aCmd_2$ and $\aCmd_1\PAR[\sSYS]\aCmd_2$ to
$\aCmd_1\PAR\aCmd_2$; thus, $(\aCmd_1\PAR[\sCTA]\aCmd_2\PAR\aCmd_3)$ should
be read as $(\exists\bThrd\xcta\cThrd\not\xcta\aThrd)$
$(\aCmd_1\RPAR[\bThrd]\aCmd_2\RPAR[\cThrd]\aCmd_3)$.

  
We use common syntax sugar, such as \emph{extended expressions}, $\aEExp$,
which include memory locations.  For example, if $\aEExp$ includes a single
occurrence of $\aLoc$, then $\bLoc\GETS\aEExp\SEMI \aCmd$ is shorthand for
$\aReg\GETS\aLoc\SEMI\bLoc\GETS\aEExp[\aReg/\aLoc]\SEMI \aCmd$.  Each
occurrence of $\aLoc$ in an extended expression corresponds to an separate
read.  We also write $\IF{\aExp} \THEN \aCmd \FI$ as shorthand for
$\IF{\aExp} \THEN \aCmd\ELSE \SKIP\FI$.

% Throughout \textsection\ref{sec:intro}--\ref{sec:tool} we 
% require that
% \begin{itemize}
% \item each register is assigned at most once in a program.
%   % \end{itemize}
%   % In \textsection\ref{sec:complications} and following, we
%   % require instead that
%   % \begin{itemize}
%   % \end{itemize}
% \end{itemize}
% In \textsection\ref{sec:additional}, we drop this restriction, requiring
% instead that
% \begin{itemize}
% \item there are registers
%   $\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$, that do not
%   appear in programs: $\aCmd[\bExp/\uReg{\aEv}]=\aCmd$.
% \end{itemize}


The semantics is built from the following.
\begin{itemize}
\item a set of \emph{events} $\AllEvents$, ranged over by $\aEv$, $\bEv$,
  $\cEv$, %$\dEv$,
  and subsets ranged over by $\aEvs$, $\bEvs$, $\cEvs$,  
\item a set of \emph{logical formulae} $\Formulae$, ranged over by $\aForm$,
  $\bForm$, $\cForm$,
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$, $\bAct$, 
\item a family of \emph{quiescence symbols} $\Q{\aLoc}$, indexed by location.
\end{itemize}

We require that
\begin{itemize}
\item registers include %\emph{event registers}
  $\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$ which do not appear in commands:
  $\aCmd[\bExp/\uReg{\aEv}]=\aCmd$,
\item formulae include $\TRUE$, $\FALSE$, $\Q{\aLoc}$, and the equalities $(\aExp{=}\bExp)$ and $(\aLoc{=}\aExp)$,
\item formulae are closed under negation, conjunction, disjunction, and
  substitutions $[\aExp/\aReg]$, $[\aExp/\aLoc]$, $[\aForm/\Q{\aLoc}]$,
\item there is a relation $\rimpliesdef$ between
  formulae, capturing entailment, 
\item $\rimpliesdef$ has the expected semantics for $=$, $\lnot$, $\land$, $\lor$,
  $\limplies$ and substitution.
\end{itemize}
We relax the first assumption in examples, assuming that each register is
assigned at most once.

Logical formulae include equations over registers, such as
$(\aReg{=}\bReg{+}1)$.  For \xLIR{}, we also include equations over memory
references, such as $(\aLoc{=}1)$.  Formulae are subject to substitutions;
actions are not.  We use expressions as formulae, coercing $\aExp$ to
$\aExp{\neq}0$.  Equations have precedence over logical operators; thus
$\aReg{=}\aVal\limplies\bReg{>}\bVal$ is read
$(\aReg{=}\aVal)\limplies(\bReg{>}\bVal)$.  As usual, implication associates
to the right; thus $\aForm\limplies\bForm\limplies\cForm$ is read
$\aForm\limplies(\bForm\limplies\cForm)$.

We say
$\aForm$ is a \emph{tautology} if $\TRUE\vDash\aForm$.
We say
$\aForm$ is \emph{unsatisfiable} if $\aForm\vDash\FALSE$.



We also require that there is a subset of actions, distinguishing
$\sreaddef$ %and $\sreleasedef$
actions. 
We require several binary relations between actions, detailed in the next
subsection: 
$\rsyncdelaysdef$,
$\rcodelaysdef$,
\rsmatchesdeftext, 
$\rmatchesdef$, 
$\rblocksdef$, 
$\roverlapsdef$, 
\rsoverlapsdeftext,
\rsfencesdeftext.
We require that
\begin{gather*}
  {\rmatches}\subseteq {\rblocks}\subseteq {\roverlaps}
  \supseteq{\rsoverlaps}
  \\
  {\rsmatches}\subseteq {\rsoverlaps}\cup{\rsfences}
\end{gather*}
% $\rsoverlaps$ implies $\roverlaps$
% and that 
% $\rsmatches$ implies $\rmatches$ implies $\rblocks$ implies $\roverlaps$.


\subsection{Actions}
\label{sec:actions}

We combine access and fence modes into a single order:
% \begin{align*}
%   \begin{tikzcenter}
%     \node (wk)  at (-1, 0) {$\mathstrut\mWK$};
%     \node (rlx) at (0, 0) {$\mathstrut\mRLX$};
%     \node (ra)  at (1, 0) {$\mathstrut\mRA$};
%     \node (sc)  at (2, 0) {$\mathstrut\mSC$};
%     \draw[->](wk)to(rlx);
%     \draw[->](rlx)to(ra);
%     \draw[->](ra)to(sc);
%   \end{tikzcenter}
%   &&
%   \begin{tikzcenter}
%     \node (fsc) at (3, 0) {$\mathstrut\fSC$};
%     \node (rel) at (2, -0.2) {$\mathstrut\fREL$};
%     \node (acq) at (2,  0.2) {$\mathstrut\fACQ$};
%     \draw[->](rel)to(fsc);
%     \draw[->](acq)to(fsc);
%   \end{tikzcenter}
% \end{align*}
\begin{math}
  \!\!\smash{\hbox{\begin{tikzcenter}
        \node (wk)  at (-1, 0) {$\mathstrut\mWK$};
        \node (rlx) at (0, 0) {$\mathstrut\mRLX$};
        \node (rel) at (1,  0.2) {$\mathstrut\mREL$};
        \node (acq) at (1, -0.2) {$\mathstrut\mACQ$};
        \node (ra)  at (2, 0) {$\mathstrut\mRA$};
        \node (sc)  at (3, 0) {$\mathstrut\mSC$};
        \draw[->](wk)to(rlx);
        \draw[->](rlx)to(rel);
        \draw[->](rlx)to(acq);
        \draw[->](rel)to(ra);
        \draw[->](acq)to(ra);
        \draw[->](ra)to(sc);
      \end{tikzcenter}}}\!\!.
\end{math}
We write $\amode\lemode\bmode$ for this order.
Let $\amode\lubmode\bmode$ denote the least upper bound of $\amode$ and $\bmode$.

Let actions be reads, writes and fences:
\begin{displaymath}
  \aAct,\bAct \BNFDEF \DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DF[\ascope]{\fmode}[\aThrd]
\end{displaymath}
In definitions, we drop elements of actions that are existentially
quantified.
% 
We write $\DXP[\amode]{\aLoc}[\ascope]{}[\aThrd]$ to stand for an
\emph{access}: either $\DWP[\amode]{\aLoc}[\ascope]{}[\aThrd]$ or
$\DRP[\amode]{\aLoc}[\ascope]{}[\aThrd]$.
% , or $\DFP[\ascope]{\amode}[\aThrd]$.
We write $\DWP[\gemode\mREL]{}{}$ to stand for either $\DWP[\mREL]{}{}$ or
$\DWP[\mSC]{}{}$, and similarly for other actions and modes.

We say $\aAct \rmatchesdef \bAct$ if $\aAct=\DWP{\aLoc}{\aVal}$ and $\bAct=\DRP{\aLoc}{\aVal}$.

We say $\aAct \rblocksdef \bAct$ if $\aAct=\DWP{\aLoc}{}$ and $\bAct=\DRP{\aLoc}{}$, regardless of value.

We say $\aAct \roverlapsdef \bAct$ if $\aAct=\DXP{\aLoc}{}$ and
$\bAct=\DXP{\aLoc}{}$, regardless of access type or value.
% they access the same location.

We say $\aAct \rcodelaysdef \bAct$ if
\begin{math}
  (\aAct,\bAct)\in
  \{(\DW{\aLoc}{}, \DW{\aLoc}{}),\;(\DR{\aLoc}{}, \DW{\aLoc}{}),\;(\DW{\aLoc}{}, \DR{\aLoc}{})\} \cup 
  % \{(\DW[\mSC]{}{}\Cb \DW[\mSC]{}{})\Cc(\DR[\mSC]{}{}\Cb \DW[\mSC]{}{}) \Cc(\DW[\mSC]{}{}\Cb \DR[\mSC]{}{})\Cc(\DR[\mSC]{}{}\Cb \DR[\mSC]{}{})\}
  \{(\DX[\mSC]{}{},\DX[\mSC]{}{})\}
\end{math}.

We say $\aAct \rsyncdelaysdef \bAct$ if
\begin{math}
  (\aAct,\bAct)\in\{
    ( \aAct                     \Cb\DW[\gemode\mREL]{}{}      )\Cc
    ( \aAct                     \Cb\DF{\gemode\fREL}          )\Cc
    ( \DR{}{}                   \Cb\DF{\gemode\fACQ}          )\Cc 
    %( \DR{\aLoc}{}              \Cb\DR[\gemode\mACQ]{\aLoc}{} )\Cc
    ( \DR[\gemode\mACQ]{}{}     \Cb\bAct                      )\Cc 
    ( \DF{\gemode\fACQ}         \Cb\bAct                      )\Cc
    ( \DF{\gemode\fREL}         \Cb\DW{}{}                    )\Cc
    ( \DW[\gemode\mREL]{\aLoc}{}\Cb\DW{\aLoc}{}               )\}
\end{math}.\footnote{For \PTX, one could additionally include
  \begin{math}
    (\DR{\aLoc}{}, \DR[\gemode\mACQ]{\aLoc}{}),
  \end{math}
  but this is not sound for Arm or \IMM{}.}

% Let $\DWP[\gemode\mREL]{}{}$ and $\DFP{\gemode\fREL}$ be
% $\sreleasedef$ actions.
Actions $\DRP{}{}$ are $\sreaddef$ actions.

\begin{definition}  
  We say
  $\DXP[\amode_1]{\aLoc}[\ascope_1]{}[\aThrd_1] \rsoverlapsdef
  \DXP[\xmode_2]{\aLoc}[\xscope_2]{}[\xThrd_2]$ when %they overlap and
  either
  \begin{multicols}{2}
    \begin{enumerate}[,label=(2\alph*),ref=2\alph*]      
    \item[{\labeltext[1]{(1)}{moral-local}}]
    $\aThrd_1=\xThrd_2$, or
    \labeltext[2]{}{moral-nonlocal}
    \item $\amode_1,\xmode_2\gemode\mRLX$,
    \item if $\ascope_1=\sCTA$ or $\xscope_2=\sCTA$ then $\aThrd_1\xcta\xThrd_2$, %and
    \item if $\ascope_1=\sGPU$ or $\xscope_2=\sGPU$ then $\aThrd_1\xgpu\xThrd_2$.
    \end{enumerate}
  \end{multicols}
  \smallskip

  We say
  $\DFP[\ascope_1]{\amode_1}[\aThrd_1] \rsfencesdef \DFP[\xscope_2]{\xmode_2}[\xThrd_2]$
  when $\amode_1=\xmode_2=\fSC$ and either \eqref{moral-local} or
  \eqref{moral-nonlocal} apply, from the definition of $\rsoverlaps$.

  We say $\aAct \rsmatchesdef \bAct$ when $\aAct$ is a release, $\bAct$ is an
  acquire, and either $\aAct\rsoverlaps \bAct$ or $\aAct\rsfences
  \bAct$. \todo{This looks wrong.}

\end{definition}

Note that for a \CPU{}s, all action have scope $\sSYS$ and mode $\mRLX$ or
greater.  For this subset of actions, $\rsoverlapsdef$ is the same as
$\roverlapsdef$ and $\rsfencesdef$ applies to any pair of $\fSC$ fences.






\subsection{Pomsets with Predicate Transformers}
\label{sec:pomsets}

The semantics here includes all the features of \cite[\textsection9]{PwT}:
Register Recycling, Register Consistency, Fences, and \RMW{}s.  We
account for Address Calculation and If-Closure in \textsection\ref{sec:addr-if}.
We have proposals to account for Dead Store Elimination, Store Forwarding,
and Monotonicity in \textsection\ref{sec:merge}.
\begin{definition}  
  \label{def:labeling:consistent}
  Let $\labeling: \aEvs \fun \Act$.
  Then we define
  \begin{math}
    \regForm{\labeling}=
    \textstyle\bigwedge_{\{(\aEv,\aVal)\in(\aEvs\times\Val)\mid\labeling(\aEv)=\DRP{}{\aVal}\}}(\uReg{\aEv}{=}\aVal)
  \end{math}.
  
  We say that $\aForm$ is \emph{$\labeling$-consistent} if $\aForm\land\regForm{\labeling}$ is satisfiable.
  We say that it is \emph{$\labeling$-inconsistent} otherwise.
\end{definition}

\begin{definition}
  \label{def:trans}
  A \emph{$\labeling$-predicate transformer} is a %monotone
  function
  $\aTr{}{}:\Formulae\fun\Formulae$ such that
  \begin{multicols}{2}
    \begin{enumerate}[,label=(\textsc{x}\arabic*),ref=\textsc{x}\arabic*]
    % \item \label{tr-false}
    %   $\aTr{}{\FALSE}\riff\FALSE$,    
    \item \label{tr-and}
      $\aTr{}{\bForm_1\land\bForm_2}\riff\aTr{}{\bForm_1}\land\aTr{}{\bForm_2}$,    
    \item \label{tr-or}
      $\aTr{}{\bForm_1\lor\bForm_2}\riff\aTr{}{\bForm_1}\lor\aTr{}{\bForm_2}$,
    \item \label{tr-implies}
      if $\aForm \rimplies \bForm$, then $\aTr{}{\aForm} \rimplies
      \aTr{}{\bForm}$,
    \item \label{tr-false}
      if $\bForm$ is $\labeling$-inconsistent then $\aTr{}{\bForm}$ is $\labeling$-inconsistent.
    \end{enumerate}
  \end{multicols}
\end{definition}

\begin{definition}
  \label{def:family}
  A \emph{family of $\labeling$-predicate transformers} consists
  of a $\labeling$-predicate transformer $\aTr{\bEvs}{}$ for each
  $\bEvs\subseteq\AllEvents$, such that if $\cEvs \cap \aEvs \subseteq \bEvs$
  then $\aTr{\cEvs}{\bForm} \rimplies \aTr{\bEvs}{\bForm}$.

  We write $\aTr{}{\bForm}$ as an abbreviation of $\aTr{\aEvs}{\bForm}$.
\end{definition}

\begin{definition}
  \label{def:pomset}
  A \emph{pomset with predicate transformers} 
  is a tuple $(\aEvs, \labeling, \labelingForm, \aTr{}{}, {\aTerm}, {\ltdep}, {\ltsync}, {\ltloc}, {\rrmw})$ where
  \begin{enumerate}[,label=(\textsc{m}\arabic*),ref=\textsc{m}\arabic*]
    \makecounter{BE}
  \item \label{pom-E} \makecounter{E}
    $\aEvs\subseteq\AllEvents$ is a set of \emph{events},
    \makecounter{Blambda}
  \item \label{pom-lambda} \makecounter{lambda}
    $\labeling: \aEvs \fun \Act$ defines a \emph{label} for each event,
    \makecounter{Bkappa}
  \item \label{pom-kappa} \makecounter{kappa}
    $\labelingForm:\aEvs\fun\Formulae$ defines a \emph{precondition} for each event,
    such that
    \begin{enumerate}
    \item \label{pom-kappa-sat}
      $\labelingForm(\aEv)$ is $\labeling$-consistent,
    \end{enumerate}
    \makecounter{Btau}
  \item \label{pom-tau} \makecounter{tau}
    $\aTr{}{}:2^{\AllEvents}\fun\Formulae \fun\Formulae$ is a \emph{family of $\labeling$-predicate transformers}, 
    \makecounter{Bterm}
  \item \label{pom-term} \makecounter{term}
    $\aTerm:\Formulae$ is a \emph{termination condition}, such that 
    \begin{multicols}{2}
      \begin{enumerate}
      \item \label{pom-term-sat}
        $\aTerm$ is $\labeling$-consistent,
      \item \label{pom-term-tau}
        $\aTerm\rimplies\aTr{}{\TRUE}$,
      \end{enumerate}
    \end{multicols}
    \makecounter{Bledep}
  \item \label{pom-ledep} \makecounter{ledep}
    ${\ltdep} : (\aEvs\times\aEvs)$ is a strict partial order capturing \emph{dependency},
    \makecounter{Blesync}
  \item \label{pom-lesync} \makecounter{lesync}
    ${\ltsync} : (\aEvs\times\aEvs)$ is a strict partial order capturing \emph{synchronization}, 
    \makecounter{Bleloc}
  \item \label{pom-leloc} \makecounter{leloc}
    ${\ltloc} : (\aEvs\times\aEvs)$ is a strict partial order capturing \emph{per-location order}, such that 
    \begin{enumerate}
    \item \label{pom-leloc-lesync}
      if $\labeling(\bEv)\roverlaps\labeling(\aEv)$ 
      then $\bEv\ltsync\aEv$ implies $\bEv\ltloc\aEv$,      
    \end{enumerate}
    \makecounter{Brmw}
  \item \label{pom-rmw} \makecounter{rmw}
    ${\rrmw} : \aEvs\fun\aEvs$ is a partial function capturing read-modify-write \emph{atomicity}, such that
    \begin{enumerate}
    \item \label{pom-rmw-block}
      if $\bEv\xrmw\aEv$ then $\labeling(\aEv) \rblocks \labeling(\bEv)$,
    \item \label{pom-rmw-lesync} \label{pom-rmw-leloc}
      if $\bEv\xrmw\aEv$ then $\bEv \ltsync \aEv$ and $\bEv \ltloc \aEv$,    
    \item \label{pom-rmw-atomic}
      if $\labeling(\cEv)\roverlaps\labeling(\bEv)$ and if $\bEv \xrmw \aEv$ then
      \begin{enumerate}        
      \item \label{pom-rmw-atomic1}
        $\cEv\ltdep \aEv$ implies $\cEv\ledep \bEv$,
        $\cEv\ltsync \aEv$ implies $\cEv\lesync \bEv$,
        $\cEv\ltloc \aEv$ implies $\cEv\leloc \bEv$,
      \item \label{pom-rmw-atomic2}
        $\bEv\ltdep \cEv$ implies $\aEv\ledep \cEv$,
        $\bEv\ltsync \cEv$ implies $\aEv\lesync \cEv$,
        $\bEv\ltloc \cEv$ implies $\aEv\leloc \cEv$.
      \end{enumerate}
    \end{enumerate}
  \end{enumerate}

  % Let $\bEv\leexists\aEv$ when $\aEv\leloc\bEv$ implies $\bEv=\aEv$ and
  % $\labeling(\bEv) \rsoverlaps \labeling(\aEv)$ implies $\bEv\leloc\aEv$.
  % $\aEv\not\ltloc\bEv$ and if
  % $\labeling(\bEv) \rsoverlaps \labeling(\aEv)$ then $\bEv\leloc\aEv$.
  % \begin{math}
  %   \smash{\begin{cases}
  %     \bEv'\leloc\aEv' &\text{if}\; \bEv \rsmatches \aEv
  %     \\
  %     \aEv'\not\ltloc\bEv' &\text{otherwise}
  %   \end{cases}}
  % \end{math}

  A pomset is a \emph{candidate} if there is an injective relation
  ${\rrfx} : \aEvs\times\aEvs$, capturing \emph{reads-from}, such that
  \begin{enumerate}[,label=(\textsc{c}\arabic*),ref=\textsc{c}\arabic*]
    \setcounter{enumi}{\value{lambda}}
  \item[] 
    \begin{enumerate}[leftmargin=0pt]
    \item \label{cand-rf}
      if $\bEv\xrfx\aEv$ then $\labeling(\bEv) \rmatches \labeling(\aEv)$,
    \end{enumerate}
    \setcounter{enumi}{\value{Bledep}}
  \item \label{cand-ledep-rf}
    if $\bEv\xrfx\aEv$ then $\bEv \ltdep \aEv$,
    \setcounter{enumi}{\value{lesync}}
  \item[] 
    \begin{enumerate}[leftmargin=0pt]
    \item \label{cand-lesync-rf}
      if $\bEv'\lesync\bEv\xrfx\aEv\lesync\aEv'$ and $\labeling(\bEv') \rsmatches \labeling(\aEv')$ then $\bEv' \ltsync \aEv'$,
    \item \label{cand-lesync-sc}
      if $\labeling(\bEv) \rsfences \labeling(\aEv)$ then either $\bEv\lesync\aEv$ or $\aEv\lesync\bEv$, 
      \todo{Is this right?}
    \end{enumerate}
    \setcounter{enumi}{\value{leloc}}
  \item[] 
    \begin{enumerate}[leftmargin=0pt]
    \item  \label{cand-leloc-rf}
      if $\bEv\xrfx\aEv$ then $\bEv \ltloc \aEv$,
    \item \label{cand-leloc-block}
      if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then either $\cEv\leexists\bEv$ or $\aEv\leexists\cEv$,\\
      where $\bEv'{\,\leexists\,}\aEv'$ when $\aEv'{\,\leloc\,}\bEv'$ implies $\bEv'{\,=\,}\aEv'$ and
      $\labeling(\bEv') \rsoverlaps \labeling(\aEv')$ implies $\bEv'{\,\leloc\,}\aEv'$.
    \end{enumerate}
  \end{enumerate}

  A candidate pomset with $\rrfx$ is \emph{complete} if
  \begin{enumerate}[,label=(\textsc{c}\arabic*),ref=\textsc{c}\arabic*]
    \setcounter{enumi}{\value{lambda}}
  \item[] 
    \begin{enumerate}[leftmargin=0pt]
      \stepcounter{enumii}
    \item \label{top-rf}
      if $\labeling(\aEv)$ is a $\sread$ then there is some $\bEv\xrfx\aEv$,
    \end{enumerate}
    \setcounter{enumi}{\value{Bkappa}}
  \item \label{top-kappa}
    $\labelingForm(\aEv)$ is a tautology (for every $\aEv\in\aEvs$),
    \setcounter{enumi}{\value{Bterm}}
  \item \label{top-term}
    $\aTerm$ is a tautology.
  \end{enumerate}
\end{definition}

Note that for the \IMM{} model, \ref{cand-leloc-block} is equivalent to:\footnote{If all accesses are morally strong with each other, weak fulfillment
  degenerates to
  \begin{scope}
    $\forall\labelingAct(\cEv)=\DWP[]{x}{}$ either
    $\cEv \leloc \bEv$ or $\aEv \leloc \cEv$.
  \end{scope}
  If no accesses are morally strong with each other, weak fulfillment
  degenerates to
  \begin{scope}
    $\not\mkern-5mu\exists\labelingAct(\cEv)=\DWP[]{x}{}$ 
    both $\bEv \ltloc \cEv$ and $\cEv \ltloc \aEv$.
  \end{scope}
  Note that the difference between strong and weak fulfillment is limited to $\leloc$.
  We sometimes write $\lelocstrong$ for strong fulfillment and
  $\lelocweak$ for weak fulfillment.}
\begin{center}
  if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then
  either $\cEv\leloc\bEv$ or $\aEv\leloc\cEv$.
\end{center}

% Define $\leexists$ as follows.
% \begin{align*}
%   \bEv\leexists\aEv &\textwhen                      
%   \begin{cases}
%     \bEv\leloc\aEv &\text{if}\; \bEv \;\text{is morally strong with}\; \aEv
%     \\
%     \aEv\not\ltloc\bEv &\text{otherwise}
%   \end{cases}
% \end{align*}    
% A read event $\aEv$ is \emph{strongly fulfilled} if there is a
% $\bEv\xrfx\aEv$ and 
% \begin{center}
%   for any $\cEv$ that can block $\aEv$, either $\cEv\leloc\bEv$ or
%   $\aEv\leloc\cEv$.
% \end{center}
% A read event $\aEv$ is \emph{weakly fulfilled} if there is a
% $\bEv\xrfx\aEv$ and 
% \begin{center}
%   for any $\cEv$ that can block $\aEv$, either $\cEv\leexists\bEv$ or
%   $\aEv\leexists\cEv$.
% \end{center}




Let $\aPS$ range over pomsets, and $\aPSS$ over sets of pomsets.

We drop quantifiers
when clear from context, such as
$(\forall\aEv\in\aEvs)(\forall\aLoc\in\Loc)$.
We write $\bEv\lesync\aEv$ to mean that either $\bEv\ltsync\aEv$ or $\bEv=\aEv$, and similarly
for $\ledep$ and $\leloc$.
We sometimes use projection functions---for example, if
$\labeling(\aEv)=\DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$ then 
$\labelingThrd(\aEv)=\aThrd$,
$\labelingMode(\aEv)=\amode$,
$\labelingScope(\aEv)=\ascope$,
$\labelingLoc(\aEv)=\aLoc$,
$\labelingVal(\aEv)=\aVal$.

% We lift terminology from actions to events---for example, we say that $\aEv$
% writes $\aLoc$ if $\labeling(\aEv)$ writes $\aLoc$.


%\input{fig-sem.tex}
\input{fig-sem2.tex}

The semantic functions are defined in \reffig{fig:sem}.
\begin{align*}
  \begin{aligned}
    \sem[\aThrd]{\LET{\aReg}{\aExp}} &= \sLET{\aReg}{\aExp}
    \\
    \sem[\aThrd]{\PR[\amode]{\aLoc}[\ascope]{\aReg}} &= \sLOAD[\amode]{\aReg}[\ascope]{\aLoc}[\aThrd]
    \\
    \sem[\aThrd]{\PW[\amode]{\aLoc}[\ascope]{\aExp}} &= \sSTORE[\amode]{\aLoc}[\ascope]{\aExp}[\aThrd]
    \\
    \sem[\aThrd]{\PF[\ascope]{\fmode}} &= \sFENCE[\ascope]{\fmode}[\aThrd]
  \end{aligned}
  &&
  \begin{aligned}
    \sem[\aThrd]{\SKIP} &= \sSKIP 
    \\
    \sem[\aThrd]{\aCmd_1 \RPAR[\bThrd] \aCmd_2} &= \sPAR{\sem[\bThrd]{\aCmd_1}}{\sem[\aThrd]{\aCmd_2}}
    \\
    \sem[\aThrd]{\aCmd_1 \SEMI \aCmd_2} &= \sSEMI{\sem[\aThrd]{\aCmd_1}}{\sem[\aThrd]{\aCmd_2}}
    \\
    \sem[\aThrd]{\IF{\aExp}\THEN\aCmd_1\ELSE\aCmd_2\FI} &= \sIFTHEN{\aExp{\neq}0}{\sem[\aThrd]{\aCmd_1}}{\sem[\aThrd]{\aCmd_2}}
  \end{aligned}
\end{align*}
\begin{align*}
  \sem[\aThrd]{\PCAS[\amode][\bmode]{\aLoc}[\ascope]{\aReg}{\aExp}{\bExp}}
  &=
  \sCAS[\amode][\bmode]{\aLoc}[\ascope]{\aReg}{\aExp}{\bExp}[\aThrd]
  \\
  \sem[\aThrd]{\PFADD[\amode][\bmode]{\aLoc}[\ascope]{\aReg}{\aExp}}
  &=
  \sFADD[\amode][\bmode]{\aLoc}[\ascope]{\aReg}{\aExp}[\aThrd]
  \\
  \sem[\aThrd]{\PEXCHG[\amode][\bmode]{\aLoc}[\ascope]{\aReg}{\aExp}}
  &=
  \sEXCHG[\amode][\bmode]{\aLoc}[\ascope]{\aReg}{\aExp}[\aThrd]
\end{align*}

In diagrams, we use different shapes and colors for arrows and events.  These
are included only to help the reader understand why order is included.  We
adopt the following conventions:
\begin{itemize}  
\item \makebox{$\bEv\xpo\aEv$} arises from control/data/address \emph{dependency} (\ref{seq-kappa}, definition of $\labelingForm'_2(\bEv)$),
\item \makebox{$\bEv\xsync\aEv$} arises from $\rsyncdelaysdef$ \eqref{seq-delay-sync},
\item \makebox{$\bEv\xwki\aEv$} arises from $\rcodelaysdef$ \eqref{seq-delay-co},
\item \makebox{$\bEv\xrf\aEv$} arises from \emph{matching}
  \eqref{cand-ledep-rf}, \eqref{cand-lesync-rf} and \eqref{cand-leloc-rf},
\item \makebox{$\bEv\xsyncsc\aEv$} arises from \emph{strong fencing} \eqref{cand-lesync-sc},
\item \makebox{$\bEv\xwk\aEv$} arises from \emph{blocking} \eqref{cand-leloc-block}.
\end{itemize}

\clearpage
\section{Address Calculation and If-Closure}
\label{sec:addr-if}
\subsection{Address Calculation}
\label{sec:semaddr}
\begin{definition}
  \label{def:semaddr}
  %Let $\semaddr{}$ be defined as in \reffig{fig:seq}, changing $\sSTORE{}{}$ and $\sLOAD{}{}$:

  \noindent
  If $\aPS \in \sSTORE[\amode]{\cExp}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\cVal\in\Val)$
  $(\exists\aVal\in\Val)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
    \item \label{write-E-addr}
      if $\fcard{\aEvs}\leq1$,
    \item \label{write-lambda-addr}
      $\labelingAct(\aEv) = \DW[\amode]{\REF{\cVal}}[\ascope]{\aVal}[\aThrd]$,
    \item \label{write-kappa-addr}
      \begin{math}
        \labelingForm(\aEv) \riff
        \cExp{=}\cVal
        \land \aExp{=}\aVal
      \end{math},      
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{w}4]{}{write-tau-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-tau-dep-addr}
        if $\aEvs\neq\emptyset$ then 
        \makebox[0pt][l]{\begin{math}
          \aTr{\bEvs}{\bForm} \riff 
          (\cExp{=}\cVal)
          \limplies 
          \bForm
          [\aExp/\REF{\cVal}]
          [\aExp{=}\aVal/\Q{\REF{\cVal}}]
          [\TRUE/\A{\cVal}]
          [(\cExp{\neq}\Aother\land\A{\Aother})/\A{\Aother{\neq}\cVal}]
         \end{math},}
      \item \label{write-tau-empty-addr}
        if $\aEvs=\emptyset$ then
        \makebox[0pt][l]{\begin{math}
          (\forall\dVal)
        \end{math}        
        \begin{math}
          \aTr{\bEvs}{\bForm} \riff 
          (\cExp{=}\dVal)
          \limplies 
          \bForm
          [\aExp/\REF{\dVal}]
          [\FALSE/\Q{\REF{\dVal}}]
          [\FALSE/\A{\Aother}],
         \end{math}}
      \end{enumerate}
      \columnbreak
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{w}5]{}{write-term-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-term-nonempty-addr}
        if $\aEvs\neq\emptyset$ then $\aTerm \riff \cExp{=}\cVal \land \aExp{=}\aVal$,
      \item \label{write-term-empty-addr}
        if $\aEvs=\emptyset$ then $\aTerm \riff \FALSE$.
      \end{enumerate}
    \end{enumerate}
  \end{multicols}

  \medskip
  \noindent
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\cExp}[\aThrd]$ then
  $(\exists\cVal\in\Val)$
  $(\exists\aVal\in\Val)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
    \item \label{read-E-addr}
      if $\fcard{\aEvs}\leq1$,
    \item \label{read-lambda-addr}
      $\labelingAct(\aEv) = \DR[\amode]{\REF{\cVal}}[\ascope]{\aVal}[\aThrd]$
    \item \label{read-kappa-addr}
      \begin{math}
        \labelingForm(\aEv) 
        \riff
        \cExp{=}\cVal
        \land \Q{\REF{\cVal}}
      \end{math},
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{r}4]{}{read-tau-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{read-tau-dep-addr}
        if $\aEv\in\aEvs\cap\bEvs$ then
        %if $\aEv\in\aEvs$ and $\aEv\in\bEvs$ then
        % \begin{math}
        %   (\forall\aEv\in\aEvs\cap\bEvs)
        % \end{math}
        \makebox[0pt][l]{\begin{math}
            \aTr{\bEvs}{\bForm} \riff
            (\cExp{=}\cVal\limplies\aVal{=}\uReg{\aEv})
            \limplies \bForm[\uReg{\aEv}/\aReg]
          \end{math},}
      \item \label{read-tau-ind-addr}
        if $\aEv\in\aEvs\setminus\bEvs$ then
        %if $\aEv\in\aEvs$ and $\aEv\not\in\bEvs$ then
        % \begin{math}
        %   (\forall\aEv\in\aEvs\setminus\bEvs)
        % \end{math}
        \makebox[0pt][l]{\begin{math}
            \aTr{\bEvs}{\bForm} \riff
            \PBR{
              (\cExp{=}\cVal\limplies\aVal{=}\uReg{\aEv})
              \lor
              ((\cExp{=}\cVal\land\A{\cVal})\limplies\REF{\cVal}\EQ\uReg{\aEv})
            }
            \limplies
            \bForm[\uReg{\aEv}/\aReg]
          \end{math},}
        \columnbreak
      \item \label{read-tau-empty-addr}
        if $\aEvs=\emptyset$ then 
        \begin{math}
          (\forall\bReg)
        \end{math}
        \begin{math}
          \aTr{\bEvs}{\bForm} \riff 
          \bForm[\bReg/\aReg],
        \end{math}  
      \end{enumerate}  
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{r}5]{}{read-term-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{read-term-nonempty-addr}
        if $\aEvs\neq\emptyset$ or $\amode\lemode\mRLX$ then $\aTerm \riff \TRUE$. 
      \item \label{read-term-empty-addr}
        if $\aEvs=\emptyset$ and $\amode\gemode\mACQ$ then $\aTerm \riff \FALSE$. 
      \end{enumerate}      
    % \item \label{read-term-addr}
    %   if $\aEvs=\emptyset$ and $\amode\neq\mRLX$ then $\aTerm \riff \FALSE$. 
    \end{enumerate}
  \end{multicols}
\end{definition}


\subsection{If-closure}
\label{sec:semca}

\begin{definition}
  \label{def:semca}
  \label{def:partition}
  Let $\aEvs\subseteq\AllEvents$ and $\cForm:\aEvs\fun\Formulae$ and
  $\emptyForm\in\Formulae$.  We say that $\cForm$ \emph{partitions}
  $\emptyForm$ if
  %\begin{multicols}{2}
    \begin{enumerate*}
    % \item $\cForm_\aEv$ is satisfiable,
    \item if $\cForm_\aEv\land\cForm_\bEv$ is satisfiable then $\aEv=\bEv$,
    % \item $\cForm_\aEv\rimplies\emptyForm$,
    % \item $\lnot\emptyForm\lor\bigvee_{\aEv\in\aEvs}\cForm_\aEv$ is a tautology.
    \item $\emptyForm\riff\bigvee_{\aEv\in\aEvs}\cForm_\aEv$.
    \end{enumerate*}
  %\end{multicols}
  %Let $\semca{}$ be defined as in \reffig{fig:seq}, changing $\sSTORE{}{}$ and $\sLOAD{}{}$:

  
  \noindent
  If $\aPS \in \sSTORE[\amode]{\aLoc}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$
  $(\exists\emptyForm\in\{\TRUE,\FALSE\})$
  %$(\exists\emptyForm\in\Formulae)$
  \begin{multicols}{2}
  \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
  \item \label{write-E-ca}
    $\cForm$ partitions $\emptyForm$,
    %if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{write-lambda-ca}
    $\labelingAct(\aEv) = \DW[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$,
  \item \label{write-kappa-ca}
    \begin{math}
      \labelingForm(\aEv) \riff
      \cForm_\aEv
      \land \aExp{=}\aVal_\aEv
    \end{math},
    
    
  \item \label{write-tau-ca}
    % \begin{math}
    %   %   (\forall\aEv\in\aEvs\cap\bEvs)
    %   (\forall\aEv\in\aEvs)
    % \end{math}
    % \begin{math}
    %   \aTr{\bEvs}{\bForm} \riff 
    %   \cForm_\aEv
    %   \limplies 
    %   \bForm[\aExp/\aLoc]
    % \end{math},
    \begin{math}
      \begin{aligned}[t]
        \aTr{\bEvs}{\bForm} \riff
        &\textstyle\bigwedge_{\aEv\in\aEvs}
        \PBR{
          \cForm_\aEv
          \limplies 
          \bForm[\aExp/\aLoc][\aExp{=}\aVal_\aEv/\Q{\aLoc}]
        }
        \\[-.5ex]
        \land
        &
        \lnot \emptyForm
        % \textstyle (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies 
        \bForm[\aExp/\aLoc][\FALSE/\Q{\aLoc}]
      \end{aligned}
    \end{math}
    % \item
    %   \begin{math}    
    %     (\forall\aEv\in\aEvs\setminus\bEvs)
    %   \end{math}
    %   $\aTr{\bEvs}{\bForm}$ implies
    %   \begin{math}
    %     \cForm_\aEv
    %     \limplies {
    %     \bForm
    %     [\aExp/\aLoc]
    %       %     \DS{\aLoc}{\amode}
    %       %     [\FALSE/\Q{}]
    %   }
    %   \end{math}
    % \item
    %   $\aTr{\bEvs}{\bForm}$ implies
    %   \begin{math}
    %     (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
    %     \limplies {
    %     \bForm
    %     [\aExp/\aLoc]
    %       %     \DS{\aLoc}{\amode}
    %       %     [\FALSE/\Q{}]
    %   }
    %   \end{math}.
  \item \label{write-term-ca}
    \begin{math}
      \aTerm \riff
      \emptyForm
      %\PBR{\bigvee_{\aEv\in\aEvs}\cForm_\aEv}
      \land
      \bigwedge_{\aEv\in\aEvs}\PBR{\cForm_\aEv \limplies \aExp{=}\aVal_\aEv}.
    \end{math}
    % \stepcounter{enumi}
    % \item[] \labeltext[\textsc{w}5]{}{write-term-ca}
    %   \begin{enumerate}[leftmargin=0pt]
    %   \item \label{write-term-nonempty-ca}
    %     $\aTerm \riff \cForm_\aEv \limplies \aExp{=}\aVal_\aEv$,
    %   \item \label{write-term-empty-ca}
    %     $\aTerm \riff \bigvee_{\aEv\in\aEvs}\cForm_\aEv$.
    %   \end{enumerate}
  \end{enumerate}
  \end{multicols}

  \medskip
  \noindent
  \begin{minipage}{1.0\linewidth}
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\aLoc}[\aThrd]$ then
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$ 
  $(\exists\emptyForm\in\{\TRUE,\FALSE\})$
  %$(\exists\emptyForm\in\Formulae)$
  \begin{multicols}{2}
  \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  \item \label{read-E-ca}
    $\cForm$ partitions $\emptyForm$,
    %if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{read-lambda-ca}
    $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  \item \label{read-kappa-ca}
    \begin{math}
      \labelingForm(\aEv) \riff      
      \cForm_\aEv
      \land\Q{\aLoc}
    \end{math},
  \item \label{read-tau-ca}
    \begin{math}
      \begin{aligned}[t]
        (\forall\bReg)
        \aTr{\bEvs}{\bForm} \riff
        &\textstyle\bigwedge_{\aEv\in\aEvs\cap\bEvs}
        \PBR{
          \cForm_\aEv
          \limplies \aVal_\aEv{=}\uReg{\aEv}
          \limplies \bForm[\uReg{\aEv}/\aReg]
        }
        \\[-.5ex]
        \land
        &\textstyle\bigwedge_{\aEv\in\aEvs\setminus\bEvs}
        \PBR{
          \cForm_\aEv 
          \limplies
          \PBR{\aVal_\aEv{=}\uReg{\aEv} \lor \aLoc{=}\uReg{\aEv}}
          \limplies
          \bForm[\uReg{\aEv}/\aReg]
        }
        \\[-.5ex]
        \land
        &
        \lnot\emptyForm
        % \textstyle (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies 
        \bForm[\bReg/\aReg]
      \end{aligned}
    \end{math}
    \columnbreak
  % \item[] \labeltext[\textsc{r}4]{}{read-tau-ca}
  %   \begin{enumerate}[leftmargin=0pt]
  %   \item \label{read-tau-dependent-ca}
  %     \begin{math}
  %       (\forall\aEv\in\aEvs\cap\bEvs)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff
  %       \cForm_\aEv
  %       \limplies \aVal_\aEv{=}\uReg{\aEv}
  %       \limplies \bForm[\uReg{\aEv}/\aReg]
  %     \end{math},
      
  %   \item \label{read-tau-independent-ca}
  %     \begin{math}
  %       (\forall\aEv\in\aEvs\setminus\bEvs)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff
  %       \cForm_\aEv 
  %       \limplies
  %       \PBR{\aVal_\aEv{=}\uReg{\aEv} \lor \aLoc{=}\uReg{\aEv}}
  %       \limplies
  %       \bForm[\uReg{\aEv}/\aReg]
  %     \end{math},
      
  %   \item \label{read-tau-empty-ca}
  %     \begin{math}
  %       (\forall\bReg)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff 
  %       % (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
  %       (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
  %       \limplies 
  %       \bForm[\bReg/\aReg],
  %     \end{math}  
  %   \end{enumerate}  
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{r}5]{}{read-term-ca}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{read-term-nonempty-ca}
        if $\amode\lemode\mRLX$ then $\aTerm \riff \TRUE$,
      \item \label{read-term-empty-ca}
        if $\amode\gemode\mACQ$ then
        \begin{math}
          \aTerm \riff
          \emptyForm.
          %\bigvee_{\aEv\in\aEvs}\cForm_\aEv.
        \end{math}
      \end{enumerate}      
  % \item \label{read-term-ca}
  %   if $\aEvs=\emptyset$ and $\amode\neq\mRLX$ then $\aTerm \riff \FALSE$. 
  \end{enumerate}
  % \begin{multicols}{2}
  %   \noindent
  %   And either
  %   \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  %     \setcounter{enumi}{1}
  %   \item \label{read-lambda-x}
  %     $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  %   \item \label{read-kappa-x}
  %     \begin{math}
  %       \labelingForm(\aEv) \riff
  %       \cForm_\aEv
  %     \end{math},
  %   \end{enumerate}
  %   or $\amode\neq\mRLX$ and
  %   \begin{enumerate}[topsep=0pt,label=(\textsc{d}\arabic*),ref=\textsc{d}\arabic*]
  %     \setcounter{enumi}{1}
  %   \item \label{read-lambda-x}
  %     $\labelingAct(\aEv) = \DR[\mRLX]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  %   \item \label{read-kappa-x}
  %     \begin{math}
  %       \labelingForm(\aEv) \riff
  %       \cForm_\aEv\land \aLoc{=}\aVal_\aEv
  %     \end{math},
  %   \end{enumerate}
  \end{multicols}
  \end{minipage}
  % \medskip
  % Could make \textsc{d}4b:
  % \begin{math}
  %   (\forall\aEv\in\aEvs\setminus\bEvs)
  % \end{math}
  % \begin{math}
  %   \aTr{\bEvs}{\bForm} \riff
  %   \cForm_\aEv 
  %   \limplies
  %   \PBR{\aVal_\aEv{=}\uReg{\aEv} \land \aLoc{=}\uReg{\aEv}}
  %   \limplies
  %   \bForm[\uReg{\aEv}/\aReg][\uReg{\aEv}/\aLoc]
  % \end{math},
  % \medskip Similarly, let $\frf{\semca{}}$ be defined as for $\frf{\semrr{}}$
  % in \refdef{def:sem:frf}, with these definitions of $\sSTORE{}{}$ and
  % $\sLOAD{}{}$.
\end{definition}

\subsection{Address Calculation and If-closure}
\label{sec:semcaaddr}

\begin{definition}
  \label{def:semcaaddr}
  %Let $\semcaaddr{}$ be defined as in \reffig{fig:seq}, changing $\sSTORE{}{}$ and $\sLOAD{}{}$:

  \noindent
  If $\aPS \in \sSTORE[\amode]{\cExp}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\cVal:\aEvs\fun\Val)$
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$
  $(\exists\emptyForm\in\{\TRUE,\FALSE\})$
  %$(\exists\emptyForm\in\Formulae)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
    \item \label{write-E-ca-addr}
      $\cForm$ partitions $\emptyForm$,
      %if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
    \item \label{write-lambda-ca-addr}
      $\labelingAct(\aEv) = \DW[\amode]{\REF{\cVal}}[\ascope]{\aVal_\aEv}[\aThrd]$,
    \item \label{write-kappa-ca-addr}
      \begin{math}
        \labelingForm(\aEv) \riff
        \cForm_\aEv
        \land \cExp{=}\cVal_\aEv
        \land \aExp{=}\aVal_\aEv
      \end{math},      
    \item
    \begin{math}
      (\forall\dVal)
      \begin{aligned}[t]
        \aTr{\bEvs}{\bForm} \riff
        &\textstyle\bigwedge_{\aEv\in\aEvs}
        \PBR{
          \cForm_\aEv
          \limplies (\cExp{=}\cVal)
          \limplies 
          \bForm[\aExp/\aLoc][\aExp{=}\aVal_\aEv/\Q{\aLoc}]
        }
        \\[-.5ex]
        \land
        &
        \lnot\emptyForm
        %\textstyle (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies (\cExp{=}\dVal)
        \limplies 
        \bForm[\aExp/\aLoc][\FALSE/\Q{\aLoc}]
      \end{aligned}
    \end{math}
    \columnbreak
    % \stepcounter{enumi}
    % \item[] \labeltext[\textsc{w}4]{}{write-tau-ca-addr}
      % \begin{enumerate}[leftmargin=0pt]
      % \item \label{write-tau-dep-ca-addr}
      %   \begin{math}
      %     \aTr{\bEvs}{\bForm} \riff 
      %     \cForm_\aEv
      %     \limplies (\cExp{=}\cVal)
      %     \limplies 
      %     \bForm[\aExp/\REF{\cVal}]
      %   \end{math},
      % \item \label{write-tau-empty-ca-addr}
      %   \begin{math}
      %     (\forall\dVal)
      %   \end{math}
      %   \begin{math}
      %     \aTr{\bEvs}{\bForm} \riff 
      %     % (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
      %     (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
      %     \limplies (\cExp{=}\dVal)
      %     \limplies 
      %     \bForm
      %     [\aExp/\REF{\dVal}]
      %   \end{math}  
      % \end{enumerate}  
    \item \label {write-term-ca-addr}
      \begin{math}
        \aTerm \riff
        \emptyForm
        % \PBR{\bigvee_{\aEv\in\aEvs}\cForm_\aEv}
        \land
        \bigwedge_{\aEv\in\aEvs}\PBR{\cForm_\aEv \limplies \cExp{=}\cVal_\aEv \land\aExp{=}\aVal_\aEv}.
      \end{math}
    % \stepcounter{enumi}
    % \item[] \labeltext[\textsc{w}5]{}{write-term-ca-addr}
    %   \begin{enumerate}[leftmargin=0pt]
    %   \item \label{write-term-nonempty-ca-addr}
    %     $\aTerm \riff \cForm_\aEv \limplies \cExp{=}\cVal_\aEv \land \aExp{=}\aVal_\aEv$,
    %   \item \label{write-term-empty-ca-addr}
    %     \begin{math}
    %       \aTerm \riff
    %       \emptyForm.
    %       %\bigvee_{\aEv\in\aEvs}\cForm_\aEv.
    %     \end{math}
    %   \end{enumerate}
    \end{enumerate}
  \end{multicols}

  \medskip
  \noindent
  \begin{minipage}{1.0\linewidth}
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\cExp}[\aThrd]$ then
  $(\exists\cVal:\aEvs\fun\Val)$
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$ 
  $(\exists\emptyForm\in\{\TRUE,\FALSE\})$
  %$(\exists\emptyForm\in\Formulae)$
  \begin{multicols}{2}
  \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  \item \label{read-E-ca-addr}
    $\cForm$ partitions $\emptyForm$,
    %if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{read-lambda-ca-addr}
    $\labelingAct(\aEv) = \DR[\amode]{\REF{\cVal}}[\ascope]{\aVal_\aEv}[\aThrd]$
  \item \label{read-kappa-ca-addr}
    \begin{math}
      \labelingForm(\aEv) \riff
      \cForm_\aEv
      \land \cExp{=}\cVal_\aEv
      \land \Q{\REF{\cVal}}
    \end{math},
  \item \label{read-tau-ca-addr}
    \begin{math}
      \begin{aligned}[t]
        (\forall\bReg)
        \aTr{\bEvs}{\bForm} \riff
        &\textstyle\bigwedge_{\aEv\in\aEvs\cap\bEvs}
        \PBR{
          \cForm_\aEv
          \limplies (\cExp{=}\cVal_\aEv\limplies\aVal_\aEv{=}\uReg{\aEv})
          \limplies \bForm[\uReg{\aEv}/\aReg]
        }
        \\[-.5ex]
        \land
        &\textstyle\bigwedge_{\aEv\in\aEvs\setminus\bEvs}
        \PBR{
          \cForm_\aEv 
          \limplies
          \PBR{(\cExp{=}\cVal_\aEv\limplies\aVal_\aEv{=}\uReg{\aEv}) \lor (\cExp{=}\cVal_\aEv\limplies\REF{\cVal}{=}\uReg{\aEv})}
          \limplies
          \bForm[\uReg{\aEv}/\aReg]
        }
        \\[-.5ex]
        \land
        &
        \lnot\emptyForm
        %\textstyle (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies 
        \bForm[\bReg/\aReg],
      \end{aligned}
    \end{math}
  % \stepcounter{enumi}
  % \item[] \labeltext[\textsc{r}4]{}{read-tau-ca-addr}
  %   \begin{enumerate}[leftmargin=0pt]
  %   \item \label{read-tau-dependent-ca-addr}
  %     \begin{math}
  %       (\forall\aEv\in\aEvs\cap\bEvs)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff
  %       \cForm_\aEv
  %       \limplies (\cExp{=}\cVal_\aEv\limplies\aVal_\aEv{=}\uReg{\aEv})
  %       \limplies \bForm[\uReg{\aEv}/\aReg]
  %     \end{math},      
  %   \item \label{read-tau-independent-ca-addr}
  %     \begin{math}
  %       (\forall\aEv\in\aEvs\setminus\bEvs)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff
  %       \cForm_\aEv 
  %       \limplies
  %       \PBR{(\cExp{=}\cVal_\aEv\limplies\aVal_\aEv{=}\uReg{\aEv}) \lor (\cExp{=}\cVal_\aEv\limplies\REF{\cVal}{=}\uReg{\aEv})}
  %       \limplies
  %       \bForm[\uReg{\aEv}/\aReg]
  %     \end{math},      
  %   \item \label{read-tau-empty-ca-addr}
  %     \begin{math}
  %       (\forall\bReg)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff 
  %       (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
  %       \limplies 
  %       \bForm[\bReg/\aReg],
  %     \end{math}  
  %   \end{enumerate}  
    \columnbreak
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{r}5]{}{read-term-ca-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{read-term-nonempty-ca-addr}
        if $\amode\lemode\mRLX$ then $\aTerm \riff \TRUE$,
      \item \label{read-term-empty-ca-addr}
        if $\amode\gemode\mACQ$ then
        \begin{math}
          \aTerm \riff
          \emptyForm.
          %\bigvee_{\aEv\in\aEvs}\cForm_\aEv.
        \end{math}
      \end{enumerate}      
  % \item \label{read-term-ca-addr}
  %   if $\aEvs=\emptyset$ and $\amode\neq\mRLX$ then $\aTerm \riff \FALSE$. 
  \end{enumerate}
  \end{multicols}
  \end{minipage}
  % \medskip Similarly, let $\frf{\semaddr{}}$ be defined as for $\frf{\semrr{}}$
  % in \refdef{def:sem:frf}, with these definitions of $\sSTORE{}{}$ and
  % $\sLOAD{}{}$.
\end{definition}

