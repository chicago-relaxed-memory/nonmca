% r=x; x=r; s=x; 
% ||
% x=1; x=2

% Quiensence with x=1
% W1 R1 W1 W2

%\section{Notes}
% GPU stuff:
% \begin{itemize}
% \item Vulcan/Alloy
% \item OpenCL
% \item AMD PTX
% \item Matthew Sinclair/Sarita Adve stuff ``Chasing Away RAts- Semantics and
%   Evaluation for Relaxed Atomics on Heterogeneous Systems'' and his thesis
% \end{itemize}

\section{Model}
\label{sec:model}

\subsection{Preliminaries}
\label{sec:prelim}
The syntax is built from
\begin{itemize}
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$, $\bVal$, $\cVal$, $\dVal$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$, $\bReg$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$, $\bExp$,  $\cExp$,
\item a set of \emph{thread ids} $\Thrd$, ranged over by
  $\aThrd$, $\bThrd$.
\end{itemize}

\emph{Memory references} are tagged values, written $\REF{\cVal}$.  Let $\Loc$
be the set of memory references, ranged over by $\aLoc$, $\bLoc$, $\cLoc$.
We require that:
\begin{itemize}
\item values and registers are disjoint, 
\item values include at least the constants $0$ and $1$,  
\item expressions include at least registers and values, 
\item references do not appear in expressions: $\aExp[\bExp/\aLoc]=\aExp$,
\item thread ids include the \emph{top-level} id $\topThrd$. % and the \emph{test} id $\testThrd$. 
\end{itemize}
We model the following language.
\begin{gather*}
  \begin{aligned}
    \amode,\bmode \BNFDEF& \mWK
    \BNFSEP \mRLX
    \BNFSEP \mREL
    \BNFSEP \mACQ
    \BNFSEP \mRA 
    \BNFSEP \mSC
    % &
    % \fmode \BNFDEF& \fACQ 
    % \BNFSEP \fREL
    % \BNFSEP \fSC
    &\qquad \qquad
    \ascope,\bscope \BNFDEF& \sCTA
    \BNFSEP \sGPU
    \BNFSEP \sSYS
  \end{aligned}
  \\
  \begin{aligned}
    \aCmd%,\aTest
    \BNFDEF& \SKIP
    \BNFSEP \LET{\aReg}{\aExp}
    \BNFSEP \PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}
    \BNFSEP \PW[\amode]{\REF{\cExp}}[\ascope]{\aExp}
    \BNFSEP \PF[\ascope]{\fmode}
    \BNFSEP \IF{\aExp} \THEN \aCmd_1 \ELSE \aCmd_2 \FI
    \BNFSEP \aCmd_1 \SEMI \aCmd_2
    \\[-.5ex]
    \BNFSEP& \aCmd_1 \RPAR[\bThrd] \aCmd_2
    \BNFSEP \PCAS[\amode][\bmode]{\REF{\cExp}\,}[\ascope]{\aReg}{\aExp}{\bExp}
    \BNFSEP \PFADD[\amode][\bmode]{\REF{\cExp}\,}[\ascope]{\aReg}{\aExp}
    \BNFSEP \PEXCHG[\amode][\bmode]{\REF{\cExp}\,}[\ascope]{\aReg}{\aExp}
    % \BNFSEP \PCAS[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}{\bExp}
    % \BNFSEP \PFADD[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
    % \BNFSEP \PEXCHG[\amode_1][\amode_2]{\REF{\cExp}}[\ascope]{\aReg}{\aExp}
  \end{aligned}
\end{gather*}
% \emph{Access modes}, $\amode$, are {weak} ($\mWK$), are {relaxed} ($\mRLX$),
% {release-acquire} ($\mRA$), and {sequentially consistent} ($\mSC$).
% $\mRA$/$\mSC$ accesses are collectively known as \emph{synchronized
% accesses}.
% % 
% \emph{Fence modes}, $\bmode$, are {acquire} ($\fACQ$), {release} ($\fREL$), 
% and {acquire-release} ($\fSC$).  

\emph{Access modes}, $\amode$, are {weak} ($\mWK$), {relaxed} ($\mRLX$),
{release} ($\mREL$), {acquire} ($\mACQ$), {release-acquire} ($\mRA$), and
{sequentially consistent} ($\mSC$).
% 
Let expressions ($\LET{\aReg}{\aExp}$) only affect thread-local state and
thus do not have a mode.
% 
Reads ($\PR[\amode]{\REF{\cExp}}[\ascope]{\aReg}$) support
$\mWK$,
$\mRLX$,
% $\mREL$,
$\mACQ$,
% $\mRA$, 
$\mSC$. 
Writes ($\PW[\amode]{\REF{\cExp}}[\ascope]{\aReg}$) support
$\mWK$,
$\mRLX$,
$\mREL$,
% $\mACQ$,
% $\mRA$, 
$\mSC$. 
Fences ($\PF[\ascope]{\fmode}$) support
% $\mWK$,
% $\mRLX$,
$\mREL$,
$\mACQ$,
$\mRA$, 
$\mSC$.
% 
In the atomic update operations, $\amode$ is a read and $\bmode$ is a write;
we require that $\aReg$ does not occur in $\cExp$.

\emph{Scopes}, $\ascope$, are thread group ($\sCTA$), processor ($\sGPU$) and
system ($\sSYS$).

\emph{Commands}, aka \emph{statements}, $\aCmd$, include memory accesses at a
given mode, as well as the usual structural constructs.  Following
\cite{DBLP:conf/icfp/FerreiraHJ96}, $\RPAR$ denotes parallel composition.  If
$(\aCmd_1 \RPAR[\bThrd] \aCmd_2)$ is executed with thread \ID{} $\aThrd$, then
$\aCmd_1$ runs with \ID{} $\bThrd$ and $\aCmd_2$ continues under \ID{} $\aThrd$.
Top level programs run with thread \ID{} $\topThrd$.  In examples, we usually
drop thread \ID{}s.  We use the symmetric $\PAR$ operator when there is no
continuation after the parallel composition.

We use common syntax sugar, such as \emph{extended expressions}, $\aEExp$,
which include memory locations.  For example, if $\aEExp$ includes a single
occurrence of $\aLoc$, then $\bLoc\GETS\aEExp\SEMI \aCmd$ is shorthand for
$\aReg\GETS\aLoc\SEMI\bLoc\GETS\aEExp[\aReg/\aLoc]\SEMI \aCmd$.  Each
occurrence of $\aLoc$ in an extended expression corresponds to an separate
read.  We also write $\IF{\aExp} \THEN \aCmd \FI$ as shorthand for
$\IF{\aExp} \THEN \aCmd\ELSE \SKIP\FI$.

% Throughout \textsection\ref{sec:intro}--\ref{sec:tool} we 
% require that
% \begin{itemize}
% \item each register is assigned at most once in a program.
%   % \end{itemize}
%   % In \textsection\ref{sec:complications} and following, we
%   % require instead that
%   % \begin{itemize}
%   % \end{itemize}
% \end{itemize}
% In \textsection\ref{sec:additional}, we drop this restriction, requiring
% instead that
% \begin{itemize}
% \item there are registers
%   $\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$, that do not
%   appear in programs: $\aCmd[\bExp/\uReg{\aEv}]=\aCmd$.
% \end{itemize}


The semantics is built from the following.
\begin{itemize}
\item a set of \emph{events} $\AllEvents$, ranged over by $\aEv$, $\bEv$,
  $\cEv$, %$\dEv$,
  and subsets ranged over by $\aEvs$, $\bEvs$, $\cEvs$,  
\item a set of \emph{logical formulae} $\Formulae$, ranged over by $\aForm$,
  $\bForm$, $\cForm$,
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$, $\bAct$, 
\item a family of \emph{quiescence symbols} $\Q{\aLoc}$, indexed by location.
\end{itemize}

We require that
\begin{itemize}
\item registers include %\emph{event registers}
  $\uRegs{\AllEvents}=\{\uReg{\aEv}\mid\aEv\in\AllEvents\}$ which do not appear in commands:
  $\aCmd[\bExp/\uReg{\aEv}]=\aCmd$,
\item formulae include $\TRUE$, $\FALSE$, $\Q{\aLoc}$, and the equalities $(\aExp{=}\bExp)$ and $(\aLoc{=}\aExp)$,
\item formulae are closed under negation, conjunction, disjunction, and
  substitutions $[\aExp/\aReg]$, $[\aExp/\aLoc]$, $[\aForm/\Q{\aLoc}]$,
\item there is a relation $\rimpliesdef$ between
  formulae, capturing entailment, 
\item $\rimpliesdef$ has the expected semantics for $=$, $\lnot$, $\land$, $\lor$,
  $\limplies$ and substitution.
\end{itemize}
We relax the first assumption in examples, assuming that each register is
assigned at most once.

Logical formulae include equations over registers, such as
$(\aReg{=}\bReg{+}1)$.  For \xLIR{}, we also include equations over memory
references, such as $(\aLoc{=}1)$.  Formulae are subject to substitutions;
actions are not.  We use expressions as formulae, coercing $\aExp$ to
$\aExp{\neq}0$.  Equations have precedence over logical operators; thus
$\aReg{=}\aVal\limplies\bReg{>}\bVal$ is read
$(\aReg{=}\aVal)\limplies(\bReg{>}\bVal)$.  As usual, implication associates
to the right; thus $\aForm\limplies\bForm\limplies\cForm$ is read
$\aForm\limplies(\bForm\limplies\cForm)$.

We say
$\aForm$ is a \emph{tautology} if $\TRUE\vDash\aForm$.
We say
$\aForm$ is \emph{unsatisfiable} if $\aForm\vDash\FALSE$.



We also require that there is a subset of actions, distinguishing
$\sreaddef$ %and $\sreleasedef$
actions. 
We require several binary relations between actions, detailed in the next
subsection: 
$\rsyncdelaysdef$,
$\rcodelaysdef$,
\rsmatchesdeftext, 
$\rmatchesdef$, 
$\rblocksdef$, 
$\roverlapsdef$, 
\rsoverlapsdeftext,
\rsfencesdeftext, 
We require that
\begin{gather*}
  {\rsmatches}\subseteq {\rmatches}\subseteq {\rblocks}\subseteq {\roverlaps}
  \supseteq{\rsoverlaps}.
\end{gather*}
% $\rsoverlaps$ implies $\roverlaps$
% and that 
% $\rsmatches$ implies $\rmatches$ implies $\rblocks$ implies $\roverlaps$.


\subsection{Actions}
\label{sec:actions}

We combine access and fence modes into a single order:
% \begin{align*}
%   \begin{tikzcenter}
%     \node (wk)  at (-1, 0) {$\mathstrut\mWK$};
%     \node (rlx) at (0, 0) {$\mathstrut\mRLX$};
%     \node (ra)  at (1, 0) {$\mathstrut\mRA$};
%     \node (sc)  at (2, 0) {$\mathstrut\mSC$};
%     \draw[->](wk)to(rlx);
%     \draw[->](rlx)to(ra);
%     \draw[->](ra)to(sc);
%   \end{tikzcenter}
%   &&
%   \begin{tikzcenter}
%     \node (fsc) at (3, 0) {$\mathstrut\fSC$};
%     \node (rel) at (2, -0.2) {$\mathstrut\fREL$};
%     \node (acq) at (2,  0.2) {$\mathstrut\fACQ$};
%     \draw[->](rel)to(fsc);
%     \draw[->](acq)to(fsc);
%   \end{tikzcenter}
% \end{align*}
\begin{math}
  \!\!\smash{\hbox{\begin{tikzcenter}
        \node (wk)  at (-1, 0) {$\mathstrut\mWK$};
        \node (rlx) at (0, 0) {$\mathstrut\mRLX$};
        \node (rel) at (1,  0.2) {$\mathstrut\mREL$};
        \node (acq) at (1, -0.2) {$\mathstrut\mACQ$};
        \node (ra)  at (2, 0) {$\mathstrut\mRA$};
        \node (sc)  at (3, 0) {$\mathstrut\mSC$};
        \draw[->](wk)to(rlx);
        \draw[->](rlx)to(rel);
        \draw[->](rlx)to(acq);
        \draw[->](rel)to(ra);
        \draw[->](acq)to(ra);
        \draw[->](ra)to(sc);
      \end{tikzcenter}}}\!\!.
\end{math}
We write $\amode\lemode\bmode$ for this order.
Let $\amode\lubmode\bmode$ denote the least upper bound of $\amode$ and $\bmode$.

Let actions be reads, writes and fences:
\begin{displaymath}
  \aAct,\bAct \BNFDEF \DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
  \BNFSEP \DF[\ascope]{\fmode}[\aThrd]
\end{displaymath}
In examples, we systematically drop the default mode $\mRLX$ and the default
scope $\sSYS$.  In definitions, we drop elements of actions that are
existentially quantified.
% 
We write $\DXP[\amode]{\aLoc}[\ascope]{}[\aThrd]$ to stand for an
\emph{access}: either $\DWP[\amode]{\aLoc}[\ascope]{}[\aThrd]$ or
$\DRP[\amode]{\aLoc}[\ascope]{}[\aThrd]$.
% , or $\DFP[\ascope]{\amode}[\aThrd]$.
We write $\DWP[\gemode\mREL]{}{}$ to stand for either $\DWP[\mREL]{}{}$ or
$\DWP[\mSC]{}{}$, and similarly for other actions and modes.

We say $\aAct \rmatchesdef \bAct$ if $\aAct=\DWP{\aLoc}{\aVal}$ and $\bAct=\DRP{\aLoc}{\aVal}$.

We say $\aAct \rblocksdef \bAct$ if $\aAct=\DWP{\aLoc}{}$ and $\bAct=\DRP{\aLoc}{}$, regardless of value.

We say $\aAct \roverlapsdef \bAct$ if $\aAct=\DXP{\aLoc}{}$ and
$\bAct=\DXP{\aLoc}{}$, regardless of access type or value.
% they access the same location.

We say $\aAct \rcodelaysdef \bAct$ if
\begin{math}
  (\aAct,\bAct)\in
  \{(\DW{\aLoc}{}, \DW{\aLoc}{}),\;(\DR{\aLoc}{}, \DW{\aLoc}{}),\;(\DW{\aLoc}{}, \DR{\aLoc}{})\} \cup 
  % \{(\DW[\mSC]{}{}\Cb \DW[\mSC]{}{})\Cc(\DR[\mSC]{}{}\Cb \DW[\mSC]{}{}) \Cc(\DW[\mSC]{}{}\Cb \DR[\mSC]{}{})\Cc(\DR[\mSC]{}{}\Cb \DR[\mSC]{}{})\}
  \{(\DX[\mSC]{}{},\DX[\mSC]{}{})\}
\end{math}.

We say $\aAct \rsyncdelaysdef \bAct$ if
\begin{math}
  (\aAct,\bAct)\in
  \{(\aAct,             \DW[\gemode\mREL]{}{}     )\Cc
  (\aAct,               \DF{\gemode\fREL}        )\Cc
  (\DR{}{},             \DF{\gemode\fACQ}        )\Cc
  (\DR[\gemode\mACQ]{}{},\bAct                    )\Cc
  (\DF{\gemode\fACQ},   \bAct                    )\Cc
  (\DF{\gemode\fREL},   \DW{}{}                  )\Cc
  (\DW[\gemode\mREL]{\aLoc}{},\DW{\aLoc}{})\}
\end{math}.\footnote{For \PTX, one could additionally include
  \begin{math}
    (\DR{\aLoc}{}, \DR[\gemode\mACQ]{\aLoc}{}),
  \end{math}
  but this is not sound for Arm or \IMM{}.}

% Let $\DWP[\gemode\mREL]{}{}$ and $\DFP{\gemode\fREL}$ be
% $\sreleasedef$ actions.
Actions $\DRP{}{}$ are $\sreaddef$ actions.

\begin{definition}
  We assume two equivalences:
  $\PBR{\xgpu}\subseteq(\Thrd\times\Thrd)$ partitions threads by
  \emph{processor}, and $\PBR{\xcta}\subseteq\PBR{\xgpu}$ refines the processor
  partitioning into \emph{thread groups}.
  
  We say
  $\DXP[\amode_1]{\aLoc}[\ascope_1]{}[\aThrd_1] \rsoverlapsdef
  \DXP[\xmode_2]{\aLoc}[\xscope_2]{}[\xThrd_2]$ when %they overlap and
  either
  \begin{multicols}{2}
    \begin{enumerate}[,label=(2\alph*),ref=2\alph*]      
    \item[{\labeltext[1]{(1)}{moral-local}}]
    $\aThrd_1=\xThrd_2$, or
    \labeltext[2]{}{moral-nonlocal}
    \item $\amode_1,\xmode_2\gemode\mRLX$,
    \item if $\ascope_1=\sCTA$ or $\xscope_2=\sCTA$ then $\aThrd_1\xcta\xThrd_2$, %and
    \item if $\ascope_1=\sGPU$ or $\xscope_2=\sGPU$ then $\aThrd_1\xgpu\xThrd_2$.
    \end{enumerate}
  \end{multicols}
  \smallskip

  We say
  $\DFP[\ascope_1]{\amode_1}[\aThrd_1] \rsfencesdef \DFP[\xscope_2]{\xmode_2}[\xThrd_2]$
  when $\amode_1=\xmode_2=\fSC$ and either \eqref{moral-local} or
  \eqref{moral-nonlocal} apply, from the definition of $\rsoverlaps$.

  We say $\aAct \rsmatchesdef \bAct$ when $\aAct$ is a release, $\bAct$ is an
  acquire, and either $\aAct\rsoverlaps \bAct$ or $\aAct\rsfences \bAct$.

\end{definition}

Note that for a \CPU{}s, all action have scope $\sSYS$ and mode $\mRLX$ or
greater.  For this subset of actions, $\rsoverlapsdef$ is the same as
$\roverlapsdef$ and $\rsfencesdef$ applies to any pair of $\fSC$ fences.






\subsection{Pomsets with Predicate Transformers}
\label{sec:pomsets}

\begin{definition}  
  \label{def:labeling:consistent}
  Let 
  \begin{math}
    \regForm{\labeling}=
    \textstyle\bigwedge_{\{(\aEv,\aVal)\in(\aEvs\times\Val)\mid\labeling(\aEv)=\DRP{}{\aVal}\}}(\uReg{\aEv}{=}\aVal)
    \textwhere \aEvs=\fdom(\labeling)
  \end{math}.
  
  We say that $\aForm$ is \emph{$\labeling$-consistent} if $\aForm\land\regForm{\labeling}$ is satisfiable.
  We say that it is \emph{$\labeling$-inconsistent} otherwise.
\end{definition}

\begin{definition}
  \label{def:trans}
  A \emph{$\labeling$-predicate transformer} is a %monotone
  function
  $\aTr{}{}:\Formulae\fun\Formulae$ such that
  \begin{multicols}{2}
    \begin{enumerate}[,label=(\textsc{x}\arabic*),ref=\textsc{x}\arabic*]
    % \item \label{tr-false}
    %   $\aTr{}{\FALSE}\riff\FALSE$,    
    \item \label{tr-and}
      $\aTr{}{\bForm_1\land\bForm_2}\riff\aTr{}{\bForm_1}\land\aTr{}{\bForm_2}$,    
    \item \label{tr-or}
      $\aTr{}{\bForm_1\lor\bForm_2}\riff\aTr{}{\bForm_1}\lor\aTr{}{\bForm_2}$,
    \item \label{tr-implies}
      if $\aForm \rimplies \bForm$, then $\aTr{}{\aForm} \rimplies
      \aTr{}{\bForm}$,
    \item \label{tr-false}
      if $\bForm$ is $\labeling$-inconsistent then $\aTr{}{\bForm}$ is $\labeling$-inconsistent.
    \end{enumerate}
  \end{multicols}
\end{definition}

\begin{definition}
  \label{def:family}
  A \emph{family of $\labeling$-predicate transformers} consists
  of a $\labeling$-predicate transformer $\aTr{\bEvs}{}$ for each
  $\bEvs\subseteq\AllEvents$, such that if $\cEvs \cap \aEvs \subseteq \bEvs$
  then $\aTr{\cEvs}{\bForm} \rimplies \aTr{\bEvs}{\bForm}$.

  We write $\aTr{}{\bForm}$ as an abbreviation of $\aTr{\aEvs}{\bForm}$.
\end{definition}

\begin{definition}
  \label{def:pomset}
  A \emph{pomset with predicate transformers} 
  is a tuple $(\aEvs, \labeling, \labelingForm, \aTr{}{}, {\aTerm}, {\ledep}, {\lesync}, {\leloc}, {\rrmw})$ where
  \begin{enumerate}[,label=(\textsc{m}\arabic*),ref=\textsc{m}\arabic*]
    \makecounter{BE}
  \item \label{pom-E} \makecounter{E}
    $\aEvs\subseteq\AllEvents$ is a set of \emph{events},
    \makecounter{Blambda}
  \item \label{pom-lambda} \makecounter{lambda}
    $\labeling: \aEvs \fun \Act$ defines a \emph{label} for each event,
    \makecounter{Bkappa}
  \item \label{pom-kappa} \makecounter{kappa}
    $\labelingForm:\aEvs\fun\Formulae$ defines a \emph{precondition} for each event,
    such that
    \begin{enumerate}
    \item \label{pom-kappa-sat}
      $\labelingForm(\aEv)$ is $\labeling$-consistent,
    \end{enumerate}
    \makecounter{Btau}
  \item \label{pom-tau} \makecounter{tau}
    $\aTr{}{}:2^{\AllEvents}\fun\Formulae \fun\Formulae$ is a \emph{family of $\labeling$-predicate transformers}, 
    \makecounter{Bterm}
  \item \label{pom-term} \makecounter{term}
    $\aTerm:\Formulae$ is a \emph{termination condition}, such that 
    \begin{enumerate}
    \item \label{pom-term-tau}
      $\aTerm\rimplies\aTr{}{\TRUE}$,
    \end{enumerate}
    \makecounter{Bledep}
  \item \label{pom-ledep} \makecounter{ledep}
    ${\ledep} : (\aEvs\times\aEvs)$ is a partial order capturing \emph{dependency},
    \makecounter{Blesync}
  \item \label{pom-lesync} \makecounter{lesync}
    ${\lesync} : (\aEvs\times\aEvs)$ is a partial order capturing \emph{synchronization}, 
    \makecounter{Bleloc}
  \item \label{pom-leloc} \makecounter{leloc}
    ${\leloc} : (\aEvs\times\aEvs)$ is a partial order capturing \emph{per-location order}, such that 
    \begin{enumerate}
    \item \label{pom-leloc-lesync}
      if $\labeling(\bEv)\roverlaps\labeling(\aEv)$ 
      then $\bEv\lesync\aEv$ implies $\bEv\leloc\aEv$,      
    \end{enumerate}
    \makecounter{Brmw}
  \item \label{pom-rmw} \makecounter{rmw}
    ${\rrmw} : \aEvs\fun\aEvs$ is a partial function capturing read-modify-write \emph{atomicity}, such that
    \begin{enumerate}
    \item \label{pom-rmw-block}
      if $\bEv\xrmw\aEv$ then $\labeling(\aEv) \rblocks \labeling(\bEv)$,
    \item \label{pom-rmw-lesync} \label{pom-rmw-leloc}
      if $\bEv\xrmw\aEv$ then $\bEv \lesync \aEv$ and $\bEv \leloc \aEv$,    
    \item \label{pom-rmw-atomic}
      if $\labeling(\cEv)\roverlaps\labeling(\bEv)$ then
      \begin{enumerate}        
      \item \label{pom-rmw-atomic1}
        if $\bEv \xrmw \aEv$ then
        $\cEv\ledep \aEv$ implies $\cEv\ledep \bEv$,
        $\cEv\lesync \aEv$ implies $\cEv\lesync \bEv$,
        $\cEv\leloc \aEv$ implies $\cEv\leloc \bEv$,
      \item \label{pom-rmw-atomic2}
        if $\bEv \xrmw \aEv$ then
        $\bEv\ledep \cEv$ implies $\aEv\ledep \cEv$,
        $\bEv\lesync \cEv$ implies $\aEv\lesync \cEv$,
        $\bEv\leloc \cEv$ implies $\aEv\leloc \cEv$.
      \end{enumerate}
    \end{enumerate}
  \end{enumerate}

  % Let $\bEv\leexists\aEv$ when $\aEv\leloc\bEv$ implies $\bEv=\aEv$ and
  % $\labeling(\bEv) \rsoverlaps \labeling(\aEv)$ implies $\bEv\leloc\aEv$.
  % $\aEv\not\ltloc\bEv$ and if
  % $\labeling(\bEv) \rsoverlaps \labeling(\aEv)$ then $\bEv\leloc\aEv$.
  % \begin{math}
  %   \smash{\begin{cases}
  %     \bEv'\leloc\aEv' &\text{if}\; \bEv \rsmatches \aEv
  %     \\
  %     \aEv'\not\ltloc\bEv' &\text{otherwise}
  %   \end{cases}}
  % \end{math}

  A pomset is a \emph{candidate} if there is an injective relation
  ${\rrfx} : \aEvs\times\aEvs$, capturing \emph{reads-from}, such that
  \begin{enumerate}[,label=(\textsc{c}\arabic*),ref=\textsc{c}\arabic*]
    \setcounter{enumi}{\value{lambda}}
  \item[] 
    \begin{enumerate}[leftmargin=0pt]
    \item \label{cand-rf}
      if $\bEv\xrfx\aEv$ then $\labeling(\bEv) \rmatches \labeling(\aEv)$,
    \end{enumerate}
    \setcounter{enumi}{\value{Bledep}}
  \item \label{cand-ledep-rf}
    if $\bEv\xrfx\aEv$ then $\bEv \ledep \aEv$,
    \setcounter{enumi}{\value{lesync}}
  \item[] 
    \begin{enumerate}[leftmargin=0pt]
    \item \label{cand-lesync-rf}
      if $\bEv'\lesync\bEv\xrfx\aEv\lesync\aEv'$ and $\labeling(\bEv') \rsmatches \labeling(\aEv')$ then $\bEv' \lesync \aEv'$,
    \item \label{cand-lesync-sc}
      if $\labeling(\bEv) \rsfences \labeling(\aEv)$ then either $\bEv\lesync\aEv$ or $\aEv\lesync\bEv$, 
      \todo{Is this right?}
    \end{enumerate}
    \setcounter{enumi}{\value{leloc}}
  \item[] 
    \begin{enumerate}[leftmargin=0pt]
    \item  \label{cand-leloc-rf}
      if $\bEv\xrfx\aEv$ then $\bEv \leloc \aEv$,
    \item \label{cand-leloc-block}
      if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then either $\cEv\leexists\bEv$ or $\aEv\leexists\cEv$,\\
      where $\bEv'\leexists\aEv'$ when $\aEv'\leloc\bEv'$ implies $\bEv'=\aEv'$ and
      $\labeling(\bEv') \rsoverlaps \labeling(\aEv')$ implies $\bEv'\leloc\aEv'$.
    \end{enumerate}
  \end{enumerate}

  A candidate pomset with $\rrfx$ is \emph{complete} if
  \begin{enumerate}[,label=(\textsc{c}\arabic*),ref=\textsc{c}\arabic*]
    \setcounter{enumi}{\value{lambda}}
  \item[] 
    \begin{enumerate}[leftmargin=0pt]
      \stepcounter{enumii}
    \item \label{top-rf}
      if $\labeling(\aEv)$ is a $\sread$ then there is some $\bEv\xrfx\aEv$,
    \end{enumerate}
    \setcounter{enumi}{\value{Bkappa}}
  \item \label{top-kappa}
    $\labelingForm(\aEv)$ is a tautology (for every $\aEv\in\aEvs$),
    \setcounter{enumi}{\value{Bterm}}
  \item \label{top-term}
    $\aTerm$ is a tautology.
  \end{enumerate}
\end{definition}

Note that for the \IMM{} model, \ref{cand-leloc-block} is equivalent to:\footnote{If all accesses are morally strong with each other, weak fulfillment
  degenerates to
  \begin{center}
    $\forall\labelingAct(\cEv)=\DWP[]{x}{}$ either
    $\cEv \leloc \bEv$ or $\aEv \leloc \cEv$
  \end{center}

  If no accesses are morally strong with each other, weak fulfillment
  degenerates to
  \begin{center}
    $\not\mkern-5mu\exists\labelingAct(\cEv)=\DWP[]{x}{}$ 
    both $\bEv \ltloc \cEv$ and $\cEv \ltloc \aEv$
  \end{center}

  Note that the difference between strong and weak fulfillment is limited to $\leloc$.
  We sometimes write $\lelocstrong$ for strong fulfillment and
  $\lelocweak$ for weak fulfillment.}
\begin{center}
  if $\bEv\xrfx\aEv$ and $\labeling(\cEv) \rblocks \labeling(\aEv)$ then
  either $\cEv\leloc\bEv$ or $\aEv\leloc\cEv$.
\end{center}

% Define $\leexists$ as follows.
% \begin{align*}
%   \bEv\leexists\aEv &\textwhen                      
%   \begin{cases}
%     \bEv\leloc\aEv &\text{if}\; \bEv \;\text{is morally strong with}\; \aEv
%     \\
%     \aEv\not\ltloc\bEv &\text{otherwise}
%   \end{cases}
% \end{align*}    
% A read event $\aEv$ is \emph{strongly fulfilled} if there is a
% $\bEv\xrfx\aEv$ and 
% \begin{center}
%   for any $\cEv$ that can block $\aEv$, either $\cEv\leloc\bEv$ or
%   $\aEv\leloc\cEv$.
% \end{center}
% A read event $\aEv$ is \emph{weakly fulfilled} if there is a
% $\bEv\xrfx\aEv$ and 
% \begin{center}
%   for any $\cEv$ that can block $\aEv$, either $\cEv\leexists\bEv$ or
%   $\aEv\leexists\cEv$.
% \end{center}




Let $\aPS$ range over pomsets, and $\aPSS$ over sets of pomsets.

We drop quantifiers
when clear from context, such as
$(\forall\aEv\in\aEvs)(\forall\aLoc\in\Loc)$.
We write $\bEv\ltsync\aEv$ when $\bEv\lesync\aEv$ and $\bEv\neq\aEv$, and similarly
for $\ltdep$ and $\ltloc$.
We sometimes use projection functions---for example, if
$\labeling(\aEv)=\DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]$ then 
$\labelingThrd(\aEv)=\aThrd$,
$\labelingMode(\aEv)=\amode$,
$\labelingScope(\aEv)=\ascope$,
$\labelingLoc(\aEv)=\aLoc$,
$\labelingVal(\aEv)=\aVal$.

% We lift terminology from actions to events---for example, we say that $\aEv$
% writes $\aLoc$ if $\labeling(\aEv)$ writes $\aLoc$.

\subsection{Semantics}

%\input{fig-sem.tex}
\input{fig-sem2.tex}

See \reffig{fig:sem}.

In diagrams, we use different shapes and colors for arrows and events.  These
are included only to help the reader understand why order is included.  We
adopt the following conventions:
\begin{itemize}  
\item \makebox{$\bEv\xpo\aEv$} arises from control/data/address \emph{dependency} (\ref{seq-kappa}, definition of $\labelingForm'_2(\bEv)$),
\item \makebox{$\bEv\xsync\aEv$} arises from $\rsyncdelaysdef$ \eqref{seq-delay-sync},
\item \makebox{$\bEv\xwki\aEv$} arises from $\rcodelaysdef$ \eqref{seq-delay-co},
\item \makebox{$\bEv\xrf\aEv$} arises from \emph{matching}
  \eqref{cand-ledep-rf}, \eqref{cand-lesync-rf} and \eqref{cand-leloc-rf},
\item \makebox{$\bEv\xsyncsc\aEv$} arises from \emph{strong fencing} \eqref{cand-lesync-sc},
\item \makebox{$\bEv\xwk\aEv$} arises from \emph{blocking} \eqref{cand-leloc-block}.
\end{itemize}

\subsection{Address Calculation}
\label{sec:semaddr}
\begin{definition}
  \label{def:semaddr}
  %Let $\semaddr{}$ be defined as in \reffig{fig:seq}, changing $\sSTORE{}{}$ and $\sLOAD{}{}$:

  \noindent
  If $\aPS \in \sSTORE[\amode]{\cExp}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\cVal\in\Val)$
  $(\exists\aVal\in\Val)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
    \item \label{write-E-addr}
      if $\fcard{\aEvs}\leq1$,
    \item \label{write-lambda-addr}
      $\labelingAct(\aEv) = \DW[\amode]{\REF{\cVal}}[\ascope]{\aVal}[\aThrd]$,
    \item \label{write-kappa-addr}
      \begin{math}
        \labelingForm(\aEv) \riff
        \cExp{=}\cVal
        \land \aExp{=}\aVal
      \end{math},      
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{w}4]{}{write-tau-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-tau-dep-addr}
        if $\aEvs\neq\emptyset$ then 
        \makebox[0pt][l]{\begin{math}
          \aTr{\bEvs}{\bForm} \riff 
          (\cExp{=}\cVal)
          \limplies 
          \bForm[\aExp/\REF{\cVal}][\aExp{=}\aVal/\Q{\REF{\cVal}}]
        \end{math},}
      \item \label{write-tau-empty-addr}
        if $\aEvs=\emptyset$ then
        \makebox[0pt][l]{\begin{math}
          (\forall\dVal)
        \end{math}        
        \begin{math}
          \aTr{\bEvs}{\bForm} \riff 
          (\cExp{=}\dVal)
          \limplies 
          \bForm
          [\aExp/\REF{\dVal}][\FALSE/\Q{\REF{\dVal}}],
        \end{math}}
      \end{enumerate}
      \columnbreak
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{w}5]{}{write-term-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{write-term-nonempty-addr}
        if $\aEvs\neq\emptyset$ then $\aTerm \riff \cExp{=}\cVal \land \aExp{=}\aVal$,
      \item \label{write-term-empty-addr}
        if $\aEvs=\emptyset$ then $\aTerm \riff \FALSE$.
      \end{enumerate}
    \end{enumerate}
  \end{multicols}

  \medskip
  \noindent
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\cExp}[\aThrd]$ then
  $(\exists\cVal\in\Val)$
  $(\exists\aVal\in\Val)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
    \item \label{read-E-addr}
      if $\fcard{\aEvs}\leq1$,
    \item \label{read-lambda-addr}
      $\labelingAct(\aEv) = \DR[\amode]{\REF{\cVal}}[\ascope]{\aVal}[\aThrd]$
    \item \label{read-kappa-addr}
      \begin{math}
        \labelingForm(\aEv) 
        \riff
        \cExp{=}\cVal
        \land \Q{\REF{\cVal}}
      \end{math},
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{r}4]{}{read-tau-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{read-tau-dep-addr}
        if $\aEv\in\aEvs\cap\bEvs$ then
        %if $\aEv\in\aEvs$ and $\aEv\in\bEvs$ then
        % \begin{math}
        %   (\forall\aEv\in\aEvs\cap\bEvs)
        % \end{math}
        \makebox[0pt][l]{\begin{math}
            \aTr{\bEvs}{\bForm} \riff
            (\cExp{=}\cVal\limplies\aVal{=}\uReg{\aEv})
            \limplies \bForm[\uReg{\aEv}/\aReg]
          \end{math},}
      \item \label{read-tau-ind-addr}
        if $\aEv\in\aEvs\setminus\bEvs$ then
        %if $\aEv\in\aEvs$ and $\aEv\not\in\bEvs$ then
        % \begin{math}
        %   (\forall\aEv\in\aEvs\setminus\bEvs)
        % \end{math}
        \makebox[0pt][l]{\begin{math}
            \aTr{\bEvs}{\bForm} \riff
            \PBR{(\cExp{=}\cVal\limplies\aVal{=}\uReg{\aEv}) \lor (\cExp{=}\cVal\limplies\REF{\cVal}{=}\uReg{\aEv})}
            \limplies
            \bForm[\uReg{\aEv}/\aReg]
          \end{math},}
        \columnbreak
      \item \label{read-tau-empty-addr}
        if $\aEvs=\emptyset$ then 
        \begin{math}
          (\forall\bReg)
        \end{math}
        \begin{math}
          \aTr{\bEvs}{\bForm} \riff 
          \bForm[\bReg/\aReg],
        \end{math}  
      \end{enumerate}  
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{r}5]{}{read-term-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{read-term-nonempty-addr}
        if $\aEvs\neq\emptyset$ or $\amode\lemode\mRLX$ then $\aTerm \riff \TRUE$. 
      \item \label{read-term-empty-addr}
        if $\aEvs=\emptyset$ and $\amode\gemode\mACQ$ then $\aTerm \riff \FALSE$. 
      \end{enumerate}      
    % \item \label{read-term-addr}
    %   if $\aEvs=\emptyset$ and $\amode\neq\mRLX$ then $\aTerm \riff \FALSE$. 
    \end{enumerate}
  \end{multicols}
\end{definition}


\subsection{If-closure}
\label{sec:semca}

\begin{definition}
  \label{def:semca}
  \label{def:partition}
  Let $\aEvs\subseteq\AllEvents$ and $\cForm:\aEvs\fun\Formulae$ and
  $\emptyForm\in\Formulae$.  We say that $\cForm$ \emph{partitions}
  $\emptyForm$ if
  %\begin{multicols}{2}
    \begin{enumerate*}
    % \item $\cForm_\aEv$ is satisfiable,
    \item if $\cForm_\aEv\land\cForm_\bEv$ is satisfiable then $\aEv=\bEv$,
    % \item $\cForm_\aEv\rimplies\emptyForm$,
    % \item $\lnot\emptyForm\lor\bigvee_{\aEv\in\aEvs}\cForm_\aEv$ is a tautology.
    \item $\emptyForm\riff\bigvee_{\aEv\in\aEvs}\cForm_\aEv$.
    \end{enumerate*}
  %\end{multicols}
  %Let $\semca{}$ be defined as in \reffig{fig:seq}, changing $\sSTORE{}{}$ and $\sLOAD{}{}$:

  
  \noindent
  If $\aPS \in \sSTORE[\amode]{\aLoc}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$
  $(\exists\emptyForm\in\{\TRUE,\FALSE\})$
  %$(\exists\emptyForm\in\Formulae)$
  \begin{multicols}{2}
  \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
  \item \label{write-E-ca}
    $\cForm$ partitions $\emptyForm$,
    %if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{write-lambda-ca}
    $\labelingAct(\aEv) = \DW[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$,
  \item \label{write-kappa-ca}
    \begin{math}
      \labelingForm(\aEv) \riff
      \cForm_\aEv
      \land \aExp{=}\aVal_\aEv
    \end{math},
    
    
  \item \label{write-tau-ca}
    % \begin{math}
    %   %   (\forall\aEv\in\aEvs\cap\bEvs)
    %   (\forall\aEv\in\aEvs)
    % \end{math}
    % \begin{math}
    %   \aTr{\bEvs}{\bForm} \riff 
    %   \cForm_\aEv
    %   \limplies 
    %   \bForm[\aExp/\aLoc]
    % \end{math},
    \begin{math}
      \begin{aligned}[t]
        \aTr{\bEvs}{\bForm} \riff
        &\textstyle\bigwedge_{\aEv\in\aEvs}
        \PBR{
          \cForm_\aEv
          \limplies 
          \bForm[\aExp/\aLoc][\aExp{=}\aVal_\aEv/\Q{\aLoc}]
        }
        \\[-.5ex]
        \land
        &
        \lnot \emptyForm
        % \textstyle (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies 
        \bForm[\aExp/\aLoc][\FALSE/\Q{\aLoc}]
      \end{aligned}
    \end{math}
    % \item
    %   \begin{math}    
    %     (\forall\aEv\in\aEvs\setminus\bEvs)
    %   \end{math}
    %   $\aTr{\bEvs}{\bForm}$ implies
    %   \begin{math}
    %     \cForm_\aEv
    %     \limplies {
    %     \bForm
    %     [\aExp/\aLoc]
    %       %     \DS{\aLoc}{\amode}
    %       %     [\FALSE/\Q{}]
    %   }
    %   \end{math}
    % \item
    %   $\aTr{\bEvs}{\bForm}$ implies
    %   \begin{math}
    %     (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
    %     \limplies {
    %     \bForm
    %     [\aExp/\aLoc]
    %       %     \DS{\aLoc}{\amode}
    %       %     [\FALSE/\Q{}]
    %   }
    %   \end{math}.
  \item \label{write-term-ca}
    \begin{math}
      \aTerm \riff
      \emptyForm
      %\PBR{\bigvee_{\aEv\in\aEvs}\cForm_\aEv}
      \land
      \bigwedge_{\aEv\in\aEvs}\PBR{\cForm_\aEv \limplies \aExp{=}\aVal_\aEv}.
    \end{math}
    % \stepcounter{enumi}
    % \item[] \labeltext[\textsc{w}5]{}{write-term-ca}
    %   \begin{enumerate}[leftmargin=0pt]
    %   \item \label{write-term-nonempty-ca}
    %     $\aTerm \riff \cForm_\aEv \limplies \aExp{=}\aVal_\aEv$,
    %   \item \label{write-term-empty-ca}
    %     $\aTerm \riff \bigvee_{\aEv\in\aEvs}\cForm_\aEv$.
    %   \end{enumerate}
  \end{enumerate}
  \end{multicols}

  \medskip
  \noindent
  \begin{minipage}{1.0\linewidth}
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\aLoc}[\aThrd]$ then
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$ 
  $(\exists\emptyForm\in\{\TRUE,\FALSE\})$
  %$(\exists\emptyForm\in\Formulae)$
  \begin{multicols}{2}
  \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  \item \label{read-E-ca}
    $\cForm$ partitions $\emptyForm$,
    %if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{read-lambda-ca}
    $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  \item \label{read-kappa-ca}
    \begin{math}
      \labelingForm(\aEv) \riff      
      \cForm_\aEv
      \land\Q{\aLoc}
    \end{math},
  \item \label{read-tau-ca}
    \begin{math}
      \begin{aligned}[t]
        (\forall\bReg)
        \aTr{\bEvs}{\bForm} \riff
        &\textstyle\bigwedge_{\aEv\in\aEvs\cap\bEvs}
        \PBR{
          \cForm_\aEv
          \limplies \aVal_\aEv{=}\uReg{\aEv}
          \limplies \bForm[\uReg{\aEv}/\aReg]
        }
        \\[-.5ex]
        \land
        &\textstyle\bigwedge_{\aEv\in\aEvs\setminus\bEvs}
        \PBR{
          \cForm_\aEv 
          \limplies
          \PBR{\aVal_\aEv{=}\uReg{\aEv} \lor \aLoc{=}\uReg{\aEv}}
          \limplies
          \bForm[\uReg{\aEv}/\aReg]
        }
        \\[-.5ex]
        \land
        &
        \lnot\emptyForm
        % \textstyle (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies 
        \bForm[\bReg/\aReg]
      \end{aligned}
    \end{math}
    \columnbreak
  % \item[] \labeltext[\textsc{r}4]{}{read-tau-ca}
  %   \begin{enumerate}[leftmargin=0pt]
  %   \item \label{read-tau-dependent-ca}
  %     \begin{math}
  %       (\forall\aEv\in\aEvs\cap\bEvs)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff
  %       \cForm_\aEv
  %       \limplies \aVal_\aEv{=}\uReg{\aEv}
  %       \limplies \bForm[\uReg{\aEv}/\aReg]
  %     \end{math},
      
  %   \item \label{read-tau-independent-ca}
  %     \begin{math}
  %       (\forall\aEv\in\aEvs\setminus\bEvs)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff
  %       \cForm_\aEv 
  %       \limplies
  %       \PBR{\aVal_\aEv{=}\uReg{\aEv} \lor \aLoc{=}\uReg{\aEv}}
  %       \limplies
  %       \bForm[\uReg{\aEv}/\aReg]
  %     \end{math},
      
  %   \item \label{read-tau-empty-ca}
  %     \begin{math}
  %       (\forall\bReg)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff 
  %       % (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
  %       (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
  %       \limplies 
  %       \bForm[\bReg/\aReg],
  %     \end{math}  
  %   \end{enumerate}  
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{r}5]{}{read-term-ca}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{read-term-nonempty-ca}
        if $\amode\lemode\mRLX$ then $\aTerm \riff \TRUE$,
      \item \label{read-term-empty-ca}
        if $\amode\gemode\mACQ$ then
        \begin{math}
          \aTerm \riff
          \emptyForm.
          %\bigvee_{\aEv\in\aEvs}\cForm_\aEv.
        \end{math}
      \end{enumerate}      
  % \item \label{read-term-ca}
  %   if $\aEvs=\emptyset$ and $\amode\neq\mRLX$ then $\aTerm \riff \FALSE$. 
  \end{enumerate}
  % \begin{multicols}{2}
  %   \noindent
  %   And either
  %   \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  %     \setcounter{enumi}{1}
  %   \item \label{read-lambda-x}
  %     $\labelingAct(\aEv) = \DR[\amode]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  %   \item \label{read-kappa-x}
  %     \begin{math}
  %       \labelingForm(\aEv) \riff
  %       \cForm_\aEv
  %     \end{math},
  %   \end{enumerate}
  %   or $\amode\neq\mRLX$ and
  %   \begin{enumerate}[topsep=0pt,label=(\textsc{d}\arabic*),ref=\textsc{d}\arabic*]
  %     \setcounter{enumi}{1}
  %   \item \label{read-lambda-x}
  %     $\labelingAct(\aEv) = \DR[\mRLX]{\aLoc}[\ascope]{\aVal_\aEv}[\aThrd]$
  %   \item \label{read-kappa-x}
  %     \begin{math}
  %       \labelingForm(\aEv) \riff
  %       \cForm_\aEv\land \aLoc{=}\aVal_\aEv
  %     \end{math},
  %   \end{enumerate}
  \end{multicols}
  \end{minipage}
  % \medskip
  % Could make \textsc{d}4b:
  % \begin{math}
  %   (\forall\aEv\in\aEvs\setminus\bEvs)
  % \end{math}
  % \begin{math}
  %   \aTr{\bEvs}{\bForm} \riff
  %   \cForm_\aEv 
  %   \limplies
  %   \PBR{\aVal_\aEv{=}\uReg{\aEv} \land \aLoc{=}\uReg{\aEv}}
  %   \limplies
  %   \bForm[\uReg{\aEv}/\aReg][\uReg{\aEv}/\aLoc]
  % \end{math},
  % \medskip Similarly, let $\frf{\semca{}}$ be defined as for $\frf{\semrr{}}$
  % in \refdef{def:sem:frf}, with these definitions of $\sSTORE{}{}$ and
  % $\sLOAD{}{}$.
\end{definition}

\subsection{Address Calculation and If-closure}
\label{sec:semcaaddr}

\begin{definition}
  \label{def:semcaaddr}
  %Let $\semcaaddr{}$ be defined as in \reffig{fig:seq}, changing $\sSTORE{}{}$ and $\sLOAD{}{}$:

  \noindent
  If $\aPS \in \sSTORE[\amode]{\cExp}[\ascope]{\aExp}[\aThrd]$ then
  $(\exists\cVal:\aEvs\fun\Val)$
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$
  $(\exists\emptyForm\in\{\TRUE,\FALSE\})$
  %$(\exists\emptyForm\in\Formulae)$
  \begin{multicols}{2}
    \begin{enumerate}[topsep=0pt,label=(\textsc{w}\arabic*),ref=\textsc{w}\arabic*]
    \item \label{write-E-ca-addr}
      $\cForm$ partitions $\emptyForm$,
      %if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
    \item \label{write-lambda-ca-addr}
      $\labelingAct(\aEv) = \DW[\amode]{\REF{\cVal}}[\ascope]{\aVal_\aEv}[\aThrd]$,
    \item \label{write-kappa-ca-addr}
      \begin{math}
        \labelingForm(\aEv) \riff
        \cForm_\aEv
        \land \cExp{=}\cVal_\aEv
        \land \aExp{=}\aVal_\aEv
      \end{math},      
    \item
    \begin{math}
      (\forall\dVal)
      \begin{aligned}[t]
        \aTr{\bEvs}{\bForm} \riff
        &\textstyle\bigwedge_{\aEv\in\aEvs}
        \PBR{
          \cForm_\aEv
          \limplies (\cExp{=}\cVal)
          \limplies 
          \bForm[\aExp/\aLoc][\aExp{=}\aVal_\aEv/\Q{\aLoc}]
        }
        \\[-.5ex]
        \land
        &
        \lnot\emptyForm
        %\textstyle (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies (\cExp{=}\dVal)
        \limplies 
        \bForm[\aExp/\aLoc][\FALSE/\Q{\aLoc}]
      \end{aligned}
    \end{math}
    \columnbreak
    % \stepcounter{enumi}
    % \item[] \labeltext[\textsc{w}4]{}{write-tau-ca-addr}
      % \begin{enumerate}[leftmargin=0pt]
      % \item \label{write-tau-dep-ca-addr}
      %   \begin{math}
      %     \aTr{\bEvs}{\bForm} \riff 
      %     \cForm_\aEv
      %     \limplies (\cExp{=}\cVal)
      %     \limplies 
      %     \bForm[\aExp/\REF{\cVal}]
      %   \end{math},
      % \item \label{write-tau-empty-ca-addr}
      %   \begin{math}
      %     (\forall\dVal)
      %   \end{math}
      %   \begin{math}
      %     \aTr{\bEvs}{\bForm} \riff 
      %     % (\!\not\exists\aEv\in\aEvs \suchthat \cForm_\aEv)
      %     (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
      %     \limplies (\cExp{=}\dVal)
      %     \limplies 
      %     \bForm
      %     [\aExp/\REF{\dVal}]
      %   \end{math}  
      % \end{enumerate}  
    \item \label {write-term-ca-addr}
      \begin{math}
        \aTerm \riff
        \emptyForm
        % \PBR{\bigvee_{\aEv\in\aEvs}\cForm_\aEv}
        \land
        \bigwedge_{\aEv\in\aEvs}\PBR{\cForm_\aEv \limplies \cExp{=}\cVal_\aEv \land\aExp{=}\aVal_\aEv}.
      \end{math}
    % \stepcounter{enumi}
    % \item[] \labeltext[\textsc{w}5]{}{write-term-ca-addr}
    %   \begin{enumerate}[leftmargin=0pt]
    %   \item \label{write-term-nonempty-ca-addr}
    %     $\aTerm \riff \cForm_\aEv \limplies \cExp{=}\cVal_\aEv \land \aExp{=}\aVal_\aEv$,
    %   \item \label{write-term-empty-ca-addr}
    %     \begin{math}
    %       \aTerm \riff
    %       \emptyForm.
    %       %\bigvee_{\aEv\in\aEvs}\cForm_\aEv.
    %     \end{math}
    %   \end{enumerate}
    \end{enumerate}
  \end{multicols}

  \medskip
  \noindent
  \begin{minipage}{1.0\linewidth}
  If $\aPS \in \sLOAD[\amode]{\aReg}[\ascope]{\cExp}[\aThrd]$ then
  $(\exists\cVal:\aEvs\fun\Val)$
  $(\exists\aVal:\aEvs\fun\Val)$
  $(\exists\cForm:\aEvs\fun\Formulae)$ 
  $(\exists\emptyForm\in\{\TRUE,\FALSE\})$
  %$(\exists\emptyForm\in\Formulae)$
  \begin{multicols}{2}
  \begin{enumerate}[topsep=0pt,label=(\textsc{r}\arabic*),ref=\textsc{r}\arabic*]
  \item \label{read-E-ca-addr}
    $\cForm$ partitions $\emptyForm$,
    %if $\cForm_\bEv\land\cForm_\aEv$ is satisfiable then $\bEv=\aEv$,
  \item \label{read-lambda-ca-addr}
    $\labelingAct(\aEv) = \DR[\amode]{\REF{\cVal}}[\ascope]{\aVal_\aEv}[\aThrd]$
  \item \label{read-kappa-ca-addr}
    \begin{math}
      \labelingForm(\aEv) \riff
      \cForm_\aEv
      \land \cExp{=}\cVal_\aEv
      \land \Q{\REF{\cVal}}
    \end{math},
  \item \label{read-tau-ca-addr}
    \begin{math}
      \begin{aligned}[t]
        (\forall\bReg)
        \aTr{\bEvs}{\bForm} \riff
        &\textstyle\bigwedge_{\aEv\in\aEvs\cap\bEvs}
        \PBR{
          \cForm_\aEv
          \limplies (\cExp{=}\cVal_\aEv\limplies\aVal_\aEv{=}\uReg{\aEv})
          \limplies \bForm[\uReg{\aEv}/\aReg]
        }
        \\[-.5ex]
        \land
        &\textstyle\bigwedge_{\aEv\in\aEvs\setminus\bEvs}
        \PBR{
          \cForm_\aEv 
          \limplies
          \PBR{(\cExp{=}\cVal_\aEv\limplies\aVal_\aEv{=}\uReg{\aEv}) \lor (\cExp{=}\cVal_\aEv\limplies\REF{\cVal}{=}\uReg{\aEv})}
          \limplies
          \bForm[\uReg{\aEv}/\aReg]
        }
        \\[-.5ex]
        \land
        &
        \lnot\emptyForm
        %\textstyle (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
        \limplies 
        \bForm[\bReg/\aReg],
      \end{aligned}
    \end{math}
  % \stepcounter{enumi}
  % \item[] \labeltext[\textsc{r}4]{}{read-tau-ca-addr}
  %   \begin{enumerate}[leftmargin=0pt]
  %   \item \label{read-tau-dependent-ca-addr}
  %     \begin{math}
  %       (\forall\aEv\in\aEvs\cap\bEvs)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff
  %       \cForm_\aEv
  %       \limplies (\cExp{=}\cVal_\aEv\limplies\aVal_\aEv{=}\uReg{\aEv})
  %       \limplies \bForm[\uReg{\aEv}/\aReg]
  %     \end{math},      
  %   \item \label{read-tau-independent-ca-addr}
  %     \begin{math}
  %       (\forall\aEv\in\aEvs\setminus\bEvs)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff
  %       \cForm_\aEv 
  %       \limplies
  %       \PBR{(\cExp{=}\cVal_\aEv\limplies\aVal_\aEv{=}\uReg{\aEv}) \lor (\cExp{=}\cVal_\aEv\limplies\REF{\cVal}{=}\uReg{\aEv})}
  %       \limplies
  %       \bForm[\uReg{\aEv}/\aReg]
  %     \end{math},      
  %   \item \label{read-tau-empty-ca-addr}
  %     \begin{math}
  %       (\forall\bReg)
  %     \end{math}
  %     \begin{math}
  %       \aTr{\bEvs}{\bForm} \riff 
  %       (\bigwedge_{\aEv\in\aEvs}\lnot\cForm_\aEv)
  %       \limplies 
  %       \bForm[\bReg/\aReg],
  %     \end{math}  
  %   \end{enumerate}  
    \columnbreak
      \stepcounter{enumi}
    \item[] \labeltext[\textsc{r}5]{}{read-term-ca-addr}
      \begin{enumerate}[leftmargin=0pt]
      \item \label{read-term-nonempty-ca-addr}
        if $\amode\lemode\mRLX$ then $\aTerm \riff \TRUE$,
      \item \label{read-term-empty-ca-addr}
        if $\amode\gemode\mACQ$ then
        \begin{math}
          \aTerm \riff
          \emptyForm.
          %\bigvee_{\aEv\in\aEvs}\cForm_\aEv.
        \end{math}
      \end{enumerate}      
  % \item \label{read-term-ca-addr}
  %   if $\aEvs=\emptyset$ and $\amode\neq\mRLX$ then $\aTerm \riff \FALSE$. 
  \end{enumerate}
  \end{multicols}
  \end{minipage}
  % \medskip Similarly, let $\frf{\semaddr{}}$ be defined as for $\frf{\semrr{}}$
  % in \refdef{def:sem:frf}, with these definitions of $\sSTORE{}{}$ and
  % $\sLOAD{}{}$.
\end{definition}

\begin{definition}
  Let $\sLOADP{}{}$ be defined as for $\sLOAD{}{}$, adding the constraint:
  \begin{itemize}
  \item[{\labeltextXX{4d}{r}{read-tau-rmw}}]
    if $(\aEvs\cap\bEvs)=\emptyset$ then
    \begin{math}
      \aTr{\bEvs}{\bForm} \riff
      \bForm.
    \end{math}
  \end{itemize}
  If $\aPS\in\mathit{FADD}(\aReg,\cExp,\aExp,\amode,\bmode)$ then
  $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode]{\aReg}{\cExp}}{\sSTORE[\bmode]{\cExp}{\aReg{+}\aExp}})$
  \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
    $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
    $\bEv\xrmw\aEv$.
  \end{enumerate}
  If $\aPS\in\mathit{EXCHG}(\aReg,\cExp,\aExp,\amode,\bmode)$ then
  $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode]{\aReg}{\cExp}}{\sSTORE[\bmode]{\cExp}{\aExp}})$
  \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
    $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
    $\bEv\xrmw\aEv$.
  \end{enumerate}
  If $\aPS\in\mathit{CAS}(\aReg,\cExp,\aExp,\bExp,\amode,\bmode)$ then
  $(\exists \aPS_1\in\sSEMI{\sLOADP[\amode]{\aReg}{\cExp}}{\sIF{\aReg{=}\aExp}\sTHEN\sSTORE[\bmode]{\cExp}{\bExp}\sELSE\sSKIP\sFI})$
  \begin{enumerate}[topsep=0pt,label=(\textsc{u}\arabic*),ref=\textsc{u}\arabic*]
  \item if $\labeling_1(\aEv)$ is a write then there is a read $\labeling_1(\bEv)$ such that 
    $\labelingForm(\aEv)\rimplies\labelingForm(\bEv)$ and
    $\bEv\xrmw\aEv$.
  \end{enumerate}
\end{definition}


\section{Dead Store Elimination, Store Forwarding, and Monotonicity}

We validate ``monotonicity'' by updating the rules for read, write and fence
to include $(\exists\bmode\gemode\amode)$:
\begin{multicols}{3}
  \begin{enumerate}
  \item[\eqref{read-lambda}]
    $\labelingAct(\aEv) = \DR[\bmode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
  \item[\eqref{write-lambda}]
    $\labelingAct(\aEv) = \DW[\bmode]{\aLoc}[\ascope]{\aVal}[\aThrd]$,
  \item[\eqref{fence-lambda}]
    $\labelingAct(\aEv) = \DF[\ascope]{\bmode}[\aThrd]$.
  \end{enumerate}
\end{multicols}
One could do the same for scopes.


The semantics already validates:
\begin{itemize}
\item $\sem{\PW{\aLoc}{\aExp}\SEMI\PW{\aLoc}{\aExp}}\supseteq\sem{\PW{\aLoc}{\aExp}}$
\item $\sem{\PR{\aLoc}{\bReg}\SEMI\PR{\aLoc}{\aReg}}\supseteq\sem{\PR{\aLoc}{\bReg}\SEMI\LET{\aReg}{\bReg}}$
\item $\sem{\PR{\aLoc}{\aReg}}\supseteq\sem{\SKIP}$
\end{itemize}
It does not validate:
\begin{itemize}
\item $\sem{\PW{\aLoc}{\aExp}\SEMI\PW{\aLoc}{\bExp}}\supseteq\sem{\PW{\aLoc}{\bExp}}$
\item $\sem{\PW{\aLoc}{\aExp}\SEMI\PR{\aLoc}{\aReg}}\supseteq\sem{\PW{\aLoc}{\aExp}\SEMI\LET{\aReg}{\aExp}}$
\end{itemize}


% For writes, change the label rules of sequential composition to:
% \begin{enumerate}
% \item %\label{par-lambda1}
%   if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labeling(\aEv) = \labeling_1(\aEv)$, 
% \item %\label{par-lambda2}
%   if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labeling(\aEv) = \labeling_2(\aEv)$,
% \item %\label{par-lambda2}
%   if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labeling(\aEv) \in \fmerge{\labeling_1(\aEv)}{\labeling_2(\aEv)}$.
% \end{enumerate}

% \begin{definition}
%   %   Fences use the three point order:
%   %   \begin{math}
%   %     \fREL \ltmode \mSC
%   %   \end{math}
%   %   and 
%   %   \begin{math}
%   %     \fACQ \ltmode \mSC.
%   %   \end{math}
%   \noindent    
%   \begin{align*}
%     \fmerge{\DR[\amode]{\aLoc}{\aVal}}{\DR[\bmode]{\aLoc}{\aVal}} &= \{ \DR[\amode\lubmode\bmode]{\aLoc}{\aVal} \}
%     \\
%     \fmerge{\DW[\amode]{\aLoc}{\aVal}}{\DW[\bmode]{\aLoc}{\bVal}} &= \{ \DW[\amode\lubmode\bmode]{\aLoc}{\bVal} \}
%     \\
%     \fmerge{\DF{\amode}}{\DF{\bmode}} &= \{ \DF{\amode\lubmode\bmode} \}
%     \\
%     \fmerge{\aAct}{\bAct} &= \emptyset, \textotherwise
%   \end{align*}
% \end{definition}  
The semantics of \reffig{fig:sem}
validates elimination of irrelevant relaxed reads and redundant reads.
\reffig{fig:sem} also validates elimination of writes of the same value.
However, \reffig{fig:sem} does not validate general write elimination, where,
for example, $(\PW{x}{1}\SEMI\PW{x}{2})$ is refined to $\PW{x}{2}$.
Nor does it validate store forwarding, where, 
for example, $(\PW{x}{1}\SEMI\PR{x}{r})$ is refined to $(\PW{x}{1}\SEMI\LET{r}{1})$.

Elimination can be justified in pomset by \emph{merging} actions with
different labels.  A list of safe merges can be found in \cite[\textsection
E]{DBLP:conf/cgo/ChakrabortyV17} and \cite[\textsection7.1]{Kang19}.  For
examples of unsafe merges and reorderings, see \cite[\textsection
D]{DBLP:conf/cgo/ChakrabortyV17}.
See also \cite[\textsection6.2]{DBLP:journals/pacmpl/ChakrabortyV19}

Read-read and fence-fence merges can be handled by ``monotonicity'': allowing
actions to put down stronger modes in the model.  Then they can merge on the
nose.

Sad: read elimination can't be done the nice way using
\begin{math}
  \aTr{\bEvs}{\bForm} \riff \aLoc{=}\aReg  \limplies  \bForm
\end{math}
for \ref{read-tau-empty} because there may be a release-acquire pair between
the read and the matching write.

Let $\fmerge{}{}:\Act\times\Act\fun\Act$ be a partial function defined as follows.
% where $\bmode\lemode\amode$, using the order on modes from
% \textsection\ref{sec:actions}.
\begin{displaymath}
  \fmerge{\aAct}{\bAct}=
  \begin{cases}
    \aAct &
    \textif \aAct=\bAct
    \textor \aAct=\DWP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
    \textand \bAct=\DRP[\bmode]{\aLoc}[\ascope]{\aVal}[\aThrd]
    %\;\textand\; \bmode\lemode\amode
    \\
    \bAct &
    \textif  \aAct=\bAct
    \textor  \aAct=\DWP[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]
    \textand \bAct=\DWP[\bmode]{\aLoc}[\ascope]{\bVal}[\aThrd]
    %\textand \amode\lemode\bmode
    \\
    \text{undefined} & \textotherwise    
  \end{cases}
\end{displaymath}
(If we have ``monotonicity'' then we can require $\amode=\bmode$.)

% Let
% \begin{itemize}
% \item
%   \begin{math}
%     \fmerge{\DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]}{\DR[\bmode]{\aLoc}[\bscope]{\aVal}[\aThrd]} = \{
%     \DR[\amode\lubmode\bmode]{\aLoc}[\ascope\lubscope\bscope]{\aVal}[\aThrd] \}
%   \end{math},
% \item
%   \begin{math}
%     \fmerge{\DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]}{\DW[\bmode]{\aLoc}[\bscope]{\aVal}[\aThrd]} = \{
%     \DW[\amode\lubmode\bmode]{\aLoc}[\ascope\lubscope\bscope]{\aVal}[\aThrd] \}
%   \end{math},
% \item
%   \begin{math}
%     \fmerge{\DW[\amode]{\aLoc}[\ascope]{\aVal}}{\DR[\bmode\lemode\mRLX]{\aLoc}[\bscope\lescope\ascope]{\aVal}[\aThrd]} = \{
%     \DW[\amode\lubmode\bmode]{\aLoc}[\ascope\lubscope\bscope]{\aVal}[\aThrd] \}
%   \end{math},
% \item
%   \begin{math}
%     \fmerge{\DF[\ascope]{\amode}[\aThrd]}{\DF[\bscope]{\bmode}[\aThrd]} = \{ \DF [\ascope\lubscope\bscope]{\amode\lubmode\bmode}[\aThrd] \}
%   \end{math}, 
% \item
%   \begin{math}
%     \fmerge{\aAct}{\bAct} = \emptyset, 
%   \end{math}
%   otherwise.
% \end{itemize}

% \begin{itemize}
% \item
%   \begin{math}
%     \fmerge{\DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]}{\DR[\bmode]{\aLoc}[\bscope]{\aVal}[\aThrd]} = \{
%     \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd] \}
%   \end{math},
% \item
%   \begin{math}
%     \fmerge{\DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]}{\DW[\bmode]{\aLoc}[\bscope]{\aVal}[\aThrd]} = \{
%     \DW[\bmode]{\aLoc}[\bscope]{\aVal}[\aThrd] \}
%   \end{math},
% \item
%   \begin{math}
%     \fmerge{\DW[\amode]{\aLoc}[\ascope]{\aVal}}{\DR[\bmode]{\aLoc}[\bscope\lescope\ascope]{\aVal}[\aThrd]} = \{
%     \DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd] \}
%   \end{math},
% \end{itemize}

If $\aAct_0=\fmerge{\aAct_1}{\aAct_2}$, then $\aAct_1$ and $\aAct_2$ can
coalesce, resulting in $\aAct_0$.  This allows optimizations such as
$(\PW{x}{1}\SEMI \PW{x}{2})$ to $(\PW{x}{2})$ and
$(\PW{x}{1}\SEMI \PR{x}{r})$ to $(\PW{x}{1}\SEMI \PR{1}{r})$.  For
associativity of sequential composition, it is important that $\fmerge{}{}$
always take an upper bound on the modes of the two actions.  For example, it
would invalidate associativity to allow
$\DWP{\aLoc}{\aVal}=\fmerge{\DW{\aLoc}{\aVal}}{\DR[\mACQ]{\aLoc}{\aVal}}$,
although this is considered safe.

Then we can replace \ref{seq-lambda}-\ref{seq-kappa} in \reffig{fig:sem} by:
\begin{enumerate}[topsep=0pt,label=(\textsc{s}\arabic*),ref=\textsc{s}\arabic*]
\item[] \setcounter{enumi}{\value{lambda}} \labeltextX{2}{s}{seq-lambda-mergex}
  \begin{enumerate}[leftmargin=0pt]
  \item \label{seq-lambda-merge1x}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labeling(\aEv)=\labeling_1(\aEv)$,
  \item \label{seq-lambda-merge2x}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labeling(\aEv)=\labeling_2(\aEv)$,
  \item \label{seq-lambda-merge12x}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then $\labeling(\aEv)= \fmerge{\labeling_1(\aEv)}{\labeling_2(\aEv)}$,
  \end{enumerate}
\item[] \setcounter{enumi}{\value{kappa}} \labeltextX{3}{s}{seq-kappa-mergex}
  \begin{enumerate}[leftmargin=0pt]
  \item \label{seq-kappa-merge1x}
    if $\aEv\in\aEvs_1\setminus\aEvs_2$ then $\labelingForm(\aEv) \riff \labelingForm_1(\aEv)$,
  \item \label{seq-kappa-merge2x}
    if $\aEv\in\aEvs_2\setminus\aEvs_1$ then $\labelingForm(\aEv) \riff \labelingForm'_2(\aEv)$,
  % \item \label{seq-kappa-merge12}
  %   if $\aEv\in\aEvs_1\cap\aEvs_2$ then either (Correct for write-write, using if-closure) (Wrong for write-read)
  %   \begin{itemize}
  %   \item $\labelingForm(\aEv) \riff \labelingForm_1(\aEv)\land\labelingForm'_2(\aEv)$, or
  %   \item $\labelingForm(\aEv) \riff \labelingForm_1(\aEv)\lor\labelingForm'_2(\aEv)$ and $\labeling(\aEv)=\labeling_1(\aEv)=\labeling_2(\aEv)$.
  %   \end{itemize}
  \item \label{seq-kappa-merge12x}
    if $\aEv\in\aEvs_1\cap\aEvs_2$ then either
    \begin{itemize}
    \item $\labeling_1(\aEv)=\labeling(\aEv)=\labeling_2(\aEv)$ and
      $\labelingForm(\aEv) \riff \labelingForm_1(\aEv)\lor\labelingForm'_2(\aEv)$, 
    \item $\labeling_1(\aEv)=\labeling(\aEv)\neq\labeling_2(\aEv)$ and
      $\labelingForm_2'(\aEv) \riff \labelingForm(\aEv) \riff \labelingForm_1(\aEv)$ 
      (write-read),
    \item $\labeling_1(\aEv)\neq\labeling(\aEv)=\labeling_2(\aEv)$ and
      $\labelingForm_1(\aEv) \riff \labelingForm(\aEv) \riff \labelingForm_2'(\aEv)$ 
      %$\labelingForm(\aEv) \riff \labelingForm_1(\aEv) \riff \labelingForm_2'(\aEv)$
      (write-write).
    \end{itemize}
  \end{enumerate}
\end{enumerate}

Full merge:
\begin{math}
  \IF{\aExp}\THEN\PW{x}{1}\FI\SEMI\PW{x}{2}
\end{math}
can become
\begin{math}
  \PW{x}{2}.
\end{math}

Partial merge:
\begin{math}
  \PW{x}{1}\SEMI\IF{\aExp}\THEN\PW{x}{2}\FI
\end{math}
can become
\begin{math}
  \IF{\aExp}\THEN\PW{x}{2}\ELSE\PW{x}{1}\FI.
\end{math}

To get associativity, you need the ability to merge with multiple events.
\begin{align*}
  \begin{gathered}[t]
    \PW{x}{1}\SEMI
    \IF{\aExp}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\lnot\aExp\mid\DW{x}{1}}{}
        \event{b}{\aExp\mid\DW{x}{2}}{right=of a}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG\aExp}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\lnot\aExp\mid\DW{x}{2}}{}
      \end{tikzinline}}    
  \end{gathered}  
\end{align*}
This is asymmetric.  We don't expect to merge all three events in the following:
\begin{align*}
  \begin{gathered}[t]
    \IF{\BANG\aExp}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\lnot\aExp\mid\DW{x}{2}}{}
      \end{tikzinline}}    
  \end{gathered}  
  &&
  \begin{gathered}[t]
    \PW{x}{1}\SEMI
    \IF{\aExp}\THEN\PW{x}{2}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\lnot\aExp\mid\DW{x}{1}}{}
        \event{b}{\aExp\mid\DW{x}{2}}{right=of a}
      \end{tikzinline}}    
  \end{gathered}
\end{align*}
We could have a lot merging:
\begin{align*}
  \begin{gathered}[t]
    \IF{\bExp}\THEN
      \PW{x}{1}\SEMI
      \IF{\aExp}\THEN\PW{x}{3}\FI
    \FI
    \SEMI  
    \IF{\lnot\bExp}\THEN
      \PW{x}{2}\SEMI
      \IF{\aExp}\THEN\PW{x}{3}\FI
    \FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\lnot\aExp\land\bExp\mid\DW{x}{1}}{}
        \event{b}{\aExp\land\bExp\mid\DW{x}{3}}{right=of a}
        \event{c}{\lnot\aExp\land\lnot\bExp\mid\DW{x}{2}}{right=of b}
        \event{d}{\aExp\land\lnot\bExp\mid\DW{x}{3}}{right=of c}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG\aExp}\THEN\PW{x}{3}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\lnot\aExp\mid\DW{x}{3}}{}
      \end{tikzinline}}    
  \end{gathered}  
\end{align*}



Full merge:
\begin{math}
  \PW{x}{1}\SEMI\IF{\aExp}\THEN\PR{x}{r}\FI
\end{math}
can become
\begin{math}
  \PW{x}{1}\SEMI\IF{\aExp}\THEN\LET{r}{1}\FI.
\end{math}

Partial merge:
\begin{math}
  \IF{\aExp}\THEN\PW{x}{1}\FI\SEMI\PR{x}{r}
\end{math}
can become
\begin{math}
  \IF{\aExp}\THEN\PW{x}{1}\SEMI\LET{r}{1}\ELSE\PR{x}{r}\FI.
\end{math}

I don't think we need multi-merge for write-read.  Reads only affect the
world via the predicate transformer.  Any conditional surrounding a read is
baked into the predicate transformer, and so does not to persist in the
preconditions of the actions themselves after the merge.  Consider
\begin{math}
  \LET{r}{1}\SEMI\PW{x}{2}\SEMI\IF{\aExp}\THEN\PR{x}{r}\FI.
\end{math}
This can safely transform to 
\begin{math}
  \LET{r}{1}\SEMI\PW{x}{2}\SEMI\IF{\aExp}\THEN\LET{r}{2}\FI.
\end{math}

In the example below, the reads should \emph{not} merge.  Although the second
read can merge with the write.
\begin{align*}
  \begin{gathered}[t]
    \IF{\BANG\aExp}\THEN\PW{x}{1}\FI\SEMI
    \IF{\aExp}\THEN\PR{x}{r}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\lnot\aExp\mid\DW{x}{1}}{}
        \event{b}{\aExp\mid\DR{x}{1}}{right=of a}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG\aExp}\THEN\PR{x}{s}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\lnot\aExp\mid\DR{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}  
\end{align*}
Another example:
\begin{align*}
  \begin{gathered}[t]
    \PW{x}{1}\SEMI
    \IF{\aExp}\THEN\PR{x}{r}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\BANG\aExp}\THEN\PR{x}{s}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\lnot\aExp\mid\DR{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}  
\end{align*}
Another example:
\begin{align*}
  \begin{gathered}[t]
    \PW{x}{1}
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\DW{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}
  &&
  \begin{gathered}[t]
    \IF{\aExp}\THEN\PR{x}{r}\FI\SEMI
    \IF{\BANG\aExp}\THEN\PR{x}{s}\FI
    \\
    \hbox{\begin{tikzinline}[node distance=.5em]
        \event{a}{\DR{x}{1}}{}
      \end{tikzinline}}    
  \end{gathered}  
\end{align*}


Idea for multi-merge.  Use $\aEvs_1'\subseteq\aEvs_1$, with a surjective function
$\fcoalesce{}:\aEvs_1\fun\aEvs_1'$ that shows how writes merge.
\begin{itemize}
\item Require that $(\forall\bEv\in\aEvs_1')$ $\fcoalesce{\bEv}=\bEv$.
% \item Require that if $\fcoalesce{\cEv}=\bEv$ then $\fcoalesce{\bEv}=\bEv$.
% \item Thus $\aEvs_1\setminus\aEvs_1'=\{\cEv\in\aEvs_1\mid\fcoalesce{\cEv}\neq\cEv\}$. (I think)
\item Require that if $\cEv\in(\aEvs_1\setminus\aEvs_1')$ then
  $\fcoalesce{\cEv}\in\aEvs_2$---and therefore
  $\fcoalesce{\cEv}\in(\aEvs_1'\cap\aEvs_2)$.
\item Take $\aEvs=\aEvs_1'\cup\aEvs_2$.
\end{itemize}
Require that the writes that coalesce have disjoint preconditions.
\begin{itemize}
\item if $\fcoalesce{\cEv}=\fcoalesce{\cEv'}$ then $\labelingForm_1(\cEv)\land\labelingForm_1(\cEv')$ is unsatisfiable
\end{itemize}
Then each of them has to merge into the same write
$\aEv\in\aEvs_2$ using the merge function and combining the predicates as
specified above.

\begin{enumerate}[topsep=0pt,label=(\textsc{s}\arabic*),ref=\textsc{s}\arabic*]
\item[] \setcounter{enumi}{\value{lambda}} \labeltextX{2}{s}{seq-lambda-merge}
  \begin{enumerate}[leftmargin=0pt]
  \item \label{seq-lambda-merge1}
    if $\aEv\in\aEvs_1'\setminus\aEvs_2$ then $\labeling(\aEv)=\labeling_1(\aEv)$,
  \item \label{seq-lambda-merge2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1'$ then $\labeling(\aEv)=\labeling_2(\aEv)$,
  \item \label{seq-lambda-merge12}
    if $\aEv\in(\aEvs_1'\cap\aEvs_2)$ and $\cEv\in\aEvs_1$ and $\fcoalesce{\cEv}=\aEv$ then
    $\labeling(\aEv)= \fmerge{\labeling_1(\cEv)}{\labeling_2(\aEv)}$,
  \end{enumerate}
\item[] \setcounter{enumi}{\value{kappa}} \labeltextX{3}{s}{seq-kappa-merge}
  \begin{enumerate}[leftmargin=0pt]
  \item \label{seq-kappa-merge1}
    if $\aEv\in\aEvs_1'\setminus\aEvs_2$ then $\labelingForm(\aEv) \riff \labelingForm_1(\aEv)$,
  \item \label{seq-kappa-merge2}
    if $\aEv\in\aEvs_2\setminus\aEvs_1'$ then $\labelingForm(\aEv) \riff \labelingForm'_2(\aEv)$,
  \item \label{seq-kappa-merge12}
    if $\aEv\in(\aEvs_1'\cap\aEvs_2)$ then
    \begin{itemize}
    \item $\labelingForm(\aEv) \riff \labelingForm'_2(\aEv) \lor \bigvee_{\cEv\in\cEvs}\labelingForm_1(\cEv)$,
      where $\cEvs=\{\cEv\in\aEvs_1\mid \fcoalesce{\cEv}=\aEv \textand \labeling_1(\cEv)=\labeling_2(\aEv)\}$,
    \item if $\fcoalesce{\cEv}=\aEv \textand \labeling_1(\cEv)=\labeling(\aEv)\neq\labeling_2(\aEv)$ then
      $\labelingForm_2'(\cEv) \riff \labelingForm(\aEv)$ (write-read),
    \item if $\fcoalesce{\cEv}=\aEv \textand \labeling_1(\cEv)\neq\labeling(\aEv)=\labeling_2(\aEv)$ then
      $\labelingForm_1(\cEv) \riff \labelingForm(\aEv)$ (write-write).
    \end{itemize}
  \end{enumerate}
\end{enumerate}


% Maybe this works for dealing with fence-fence and read-read???
% \begin{align*}
%   \begin{aligned}[t]
%     \fmerge{\DW[\bmode]{\aLoc}[\ascope]{\bVal}[\aThrd]}{\DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]}
%     &= \{ \DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd] \}
%     \\
%     \fmerge{\DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]}{\DR[\bmode]{\aLoc}[\ascope]{\aVal}[\aThrd]}
%     &= \{ \DW[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd] \}
%     \\
%     \fmerge{\aAct}{\bAct} &= \emptyset, \textotherwise
%   \end{aligned}
%   &&
%   \begin{aligned}[t]
%     \fmerge{\DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd]}{\DR[\bmode]{\aLoc}[\ascope]{\aVal}[\aThrd]}
%     &= \{ \DR[\amode]{\aLoc}[\ascope]{\aVal}[\aThrd] \}
%     \\
%     \fmerge{\DF[\ascope]{\amode}[\aThrd]}{\DF[\ascope]{\bmode}[\aThrd]} &= \{ \DF[\ascope]{\amode}[\aThrd] \}
%     \\
%     \fmerge{\DF[\ascope]{\bmode}[\aThrd]}{\DF[\ascope]{\amode}[\aThrd]} &= \{ \DF[\ascope]{\amode}[\aThrd] \}
%   \end{aligned}
% \end{align*}


\endinput
\subsection{Generalized access modes}
This is an option.

\begin{displaymath}
  \begin{tikzpicture}
    \node (wk)  at (-1, 0) {$\mathstrut\mWK$};
    \node (rlx) at (0, 0) {$\mathstrut\mRLX$};
    \node (ra)  at (1, 0) {$\mathstrut\mRA$};
    \node (sc)  at (2, 0) {$\mathstrut\mSC$};
    \node (fsc) at (3, 0) {$\mathstrut\fSC$};
    \node (rel) at (2, -0.3) {$\mathstrut\fREL$};
    \node (acq) at (2,  0.3) {$\mathstrut\fACQ$};
    \draw[->](wk)to(rlx);
    \draw[->](rlx)to(ra);
    \draw[->](ra)to(sc);
    \draw[->](ra)to(rel);
    \draw[->](ra)to(acq);
    \draw[->](sc)to(fsc);
    \draw[->](rel)to(fsc);
    \draw[->](acq)to(fsc);
  \end{tikzpicture}
\end{displaymath}
\begin{align*}
  \fmerge{\DF{\amode}}{\DR[\bmode]{\aLoc}{\aVal}}
  = \fmerge{\DR[\amode]{\aLoc}{\aVal}}{\DF{\bmode}}
  &= \{ \DR[\amode\lubmode\bmode]{\aLoc}{\aVal} \}
  \\
  \fmerge{\DF{\amode}}{\DW[\bmode]{\aLoc}{\bVal}}
  = \fmerge{\DW[\amode]{\aLoc}{\bVal}}{\DF{\bmode}}
  &= \{ \DW[\amode\lubmode\bmode]{\aLoc}{\bVal} \}
\end{align*}
\begin{scope}
  \begin{align*}
    {\reorderra}
    &=
    \{(\DW[\amode]{}{}, \DR[\bmode]{}{}) \mid \amode\not\gemode\mSC \lor \bmode\not\gemode\mSC\}
    \cup\{(\DW[\amode]{}{}, \DW[\mRLX]{}{} \mid \amode\not\gemode\fREL \}
    \\&
    \cup\{(\DR[\amode]{}{}, \DW[\bmode]{}{}) \mid \amode=\mRLX \land \bmode=\mRLX\}
    \cup\{(\DR[\mRLX]{}{},  \DR[\bmode]{}{}) \mid \bmode\not\gemode\fACQ \}
    \\&
    \cup\{(\DF{\fREL},      \DF{\fACQ}    ) \}
    \cup\{(\DF{\fREL},      \DR[\bmode]{}{}) \}%\mid \amode=\fREL \}
    \cup\{(\DW[\amode]{}{}, \DF{\fACQ}     ) \}%\mid \bmode=\fACQ \}
  \end{align*}  
\end{scope}
In terms of reordering, $\DF{\fREL}$ is the same as $\DW[\fREL]{}{}$, and
$\DF{\fACQ}$ is the same as $\DR[\fACQ]{}{}$.
\begin{center}
  \setlength{\tabcolsep}{4pt}
  \begin{tabular}{c|ccccc|ccccc}
    &  \multicolumn{9}{|c}{$2^{\text{nd}}$} \\
    \hline
    $1^{\text{st}}$
    & $\DR[\mRLX]{}{}$  & $\DR[\mACQ]{}{}$ & $\DR[\fACQ]{}{}$& $\DR[\mSC]{}{}$  & $\DR[\fSC]{}{}$ & $\DW[\mRLX]{}{}$& $\DW[\mREL]{}{}$ & $\DW[\fREL]{}{}$& $\DW[\mSC]{}{}$& $\DW[\fSC]{}{}$\\% & $\DF{\fREL}$&$\DF{\fACQ}$ &$\DF{\fSC}$\\
    \hline                                                                                                                                                                                                                            
    $\DR[\mRLX]{}{}$ & \cmark            & \cmark          & \xmark          & \cmark           & \xmark           & \cmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\xmark       & \xmark    \\
    $\DR[\mACQ]{}{}$  & \xmark            & \xmark          & \xmark          & \xmark           & \xmark           & \xmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\xmark       & \xmark    \\
    $\DR[\fACQ]{}{}$ & \xmark            & \xmark          & \xmark          & \xmark           & \xmark           & \xmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\xmark       & \xmark    \\
    $\DR[\mSC]{}{}$  & \xmark            & \xmark          & \xmark          & \xmark           & \xmark           & \xmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\xmark       & \xmark    \\
    $\DR[\fSC]{}{}$ & \xmark            & \xmark          & \xmark          & \xmark           & \xmark           & \xmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\xmark       & \xmark    \\
    \hline                                                                                                                                                                                                                           
    $\DW[\mRLX]{}{}$ & \cmark            & \cmark          & \cmark          & \cmark           & \xmark           & \cmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\cmark       & \xmark    \\
    $\DW[\mREL]{}{}$  & \cmark            & \cmark          & \cmark          & \cmark           & \xmark           & \cmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\cmark       & \xmark    \\
    $\DW[\fREL]{}{}$ & \cmark            & \cmark          & \cmark          & \cmark           & \xmark           & \xmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\cmark       & \xmark    \\
    $\DW[\mSC]{}{}$  & \cmark            & \cmark          & \cmark          & \xmark           & \xmark           & \cmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\cmark       & \xmark    \\
    $\DW[\fSC]{}{}$ & \xmark            & \xmark          & \xmark          & \xmark           & \xmark           & \xmark          & \xmark          & \xmark          & \xmark         & \xmark         \\%  & \xmark      &\cmark       & \xmark    \\
  \end{tabular}
\end{center}

